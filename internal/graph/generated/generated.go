// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/volunteersync/backend/internal/graph/model"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Event() EventResolver
	Mutation() MutationResolver
	PublicProfile() PublicProfileResolver
	Query() QueryResolver
	Registration() RegistrationResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ActivityLog struct {
		Action    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		IPAddress func(childComplexity int) int
		UserAgent func(childComplexity int) int
	}

	AttendanceRecord struct {
		CheckedInAt  func(childComplexity int) int
		CheckedInBy  func(childComplexity int) int
		Notes        func(childComplexity int) int
		Registration func(childComplexity int) int
	}

	AuthPayload struct {
		RefreshToken func(childComplexity int) int
		Token        func(childComplexity int) int
		User         func(childComplexity int) int
	}

	Coordinates struct {
		Lat func(childComplexity int) int
		Lng func(childComplexity int) int
	}

	Event struct {
		Announcements        func(childComplexity int) int
		AvailableSpots       func(childComplexity int) int
		CanRegister          func(childComplexity int) int
		Capacity             func(childComplexity int) int
		Category             func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		CurrentRegistrations func(childComplexity int) int
		Description          func(childComplexity int) int
		EndTime              func(childComplexity int) int
		ID                   func(childComplexity int) int
		Images               func(childComplexity int) int
		IsAtCapacity         func(childComplexity int) int
		Location             func(childComplexity int) int
		Organizer            func(childComplexity int) int
		OrganizerID          func(childComplexity int) int
		RecurrenceRule       func(childComplexity int) int
		RegistrationSettings func(childComplexity int) int
		Requirements         func(childComplexity int) int
		ShareURL             func(childComplexity int) int
		ShortDescription     func(childComplexity int) int
		Slug                 func(childComplexity int) int
		StartTime            func(childComplexity int) int
		Status               func(childComplexity int) int
		Tags                 func(childComplexity int) int
		TimeCommitment       func(childComplexity int) int
		Title                func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
	}

	EventAnnouncement struct {
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		IsUrgent  func(childComplexity int) int
		Title     func(childComplexity int) int
	}

	EventCapacity struct {
		Current         func(childComplexity int) int
		Maximum         func(childComplexity int) int
		Minimum         func(childComplexity int) int
		WaitlistEnabled func(childComplexity int) int
	}

	EventConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EventEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	EventImage struct {
		AltText      func(childComplexity int) int
		DisplayOrder func(childComplexity int) int
		ID           func(childComplexity int) int
		IsPrimary    func(childComplexity int) int
		URL          func(childComplexity int) int
	}

	EventLocation struct {
		Address      func(childComplexity int) int
		City         func(childComplexity int) int
		Coordinates  func(childComplexity int) int
		Country      func(childComplexity int) int
		Instructions func(childComplexity int) int
		IsRemote     func(childComplexity int) int
		Name         func(childComplexity int) int
		State        func(childComplexity int) int
		ZipCode      func(childComplexity int) int
	}

	EventRequirements struct {
		BackgroundCheck      func(childComplexity int) int
		Interests            func(childComplexity int) int
		MinimumAge           func(childComplexity int) int
		PhysicalRequirements func(childComplexity int) int
		Skills               func(childComplexity int) int
		Training             func(childComplexity int) int
	}

	EventUpdate struct {
		CreatedAt  func(childComplexity int) int
		FieldName  func(childComplexity int) int
		ID         func(childComplexity int) int
		NewValue   func(childComplexity int) int
		OldValue   func(childComplexity int) int
		UpdateType func(childComplexity int) int
		UpdatedBy  func(childComplexity int) int
	}

	Health struct {
		Status func(childComplexity int) int
		Time   func(childComplexity int) int
	}

	Interest struct {
		Category func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	Location struct {
		City        func(childComplexity int) int
		Coordinates func(childComplexity int) int
		Country     func(childComplexity int) int
		State       func(childComplexity int) int
	}

	Mutation struct {
		AddEventImage                 func(childComplexity int, eventID string, file graphql.Upload, altText *string, isPrimary *bool) int
		AddSkill                      func(childComplexity int, input model.SkillInput) int
		ApproveRegistration           func(childComplexity int, input model.ApprovalDecisionInput) int
		BulkRegister                  func(childComplexity int, input model.BulkRegistrationInput) int
		CancelEvent                   func(childComplexity int, id string, reason *string) int
		CancelRegistration            func(childComplexity int, registrationID string, reason *string) int
		ChangePassword                func(childComplexity int, currentPassword string, newPassword string) int
		CheckInVolunteer              func(childComplexity int, input model.AttendanceInput) int
		CreateEvent                   func(childComplexity int, input model.CreateEventInput) int
		CreateEventAnnouncement       func(childComplexity int, eventID string, title string, content string, isUrgent *bool) int
		DeactivateAccount             func(childComplexity int, confirmationCode string) int
		DeleteEvent                   func(childComplexity int, id string) int
		DeleteEventAnnouncement       func(childComplexity int, id string) int
		DeleteEventImage              func(childComplexity int, id string) int
		ExportUserData                func(childComplexity int) int
		GoogleAuthURL                 func(childComplexity int, redirectURL string) int
		GoogleCallback                func(childComplexity int, code string, state string, redirectURL string) int
		Login                         func(childComplexity int, input model.LoginInput) int
		Logout                        func(childComplexity int) int
		MarkAttendance                func(childComplexity int, input model.AttendanceInput) int
		PromoteFromWaitlist           func(childComplexity int, registrationID string) int
		PublishEvent                  func(childComplexity int, id string) int
		RefreshToken                  func(childComplexity int, input model.RefreshTokenInput) int
		Register                      func(childComplexity int, input model.RegisterInput) int
		RegisterForEvent              func(childComplexity int, input model.RegisterForEventInput) int
		RemoveSkill                   func(childComplexity int, skillID string) int
		TransferRegistration          func(childComplexity int, registrationID string, newEventID string) int
		UpdateEvent                   func(childComplexity int, id string, input model.UpdateEventInput) int
		UpdateEventAnnouncement       func(childComplexity int, id string, title *string, content *string, isUrgent *bool) int
		UpdateEventImage              func(childComplexity int, id string, altText *string, isPrimary *bool, displayOrder *int) int
		UpdateInterests               func(childComplexity int, input model.InterestInput) int
		UpdateNotificationPreferences func(childComplexity int, input model.NotificationPreferencesInput) int
		UpdatePrivacySettings         func(childComplexity int, input model.PrivacySettingsInput) int
		UpdateProfile                 func(childComplexity int, input model.UpdateProfileInput) int
		UpdateRegistration            func(childComplexity int, registrationID string, personalMessage *string) int
		UploadProfilePicture          func(childComplexity int, file graphql.Upload) int
	}

	NotificationPreferences struct {
		EmailNotifications     func(childComplexity int) int
		EventReminders         func(childComplexity int) int
		NewOpportunities       func(childComplexity int) int
		NewsletterSubscription func(childComplexity int) int
		PushNotifications      func(childComplexity int) int
		SmsNotifications       func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PrivacySettings struct {
		AllowMessaging    func(childComplexity int) int
		ProfileVisibility func(childComplexity int) int
		ShowEmail         func(childComplexity int) int
		ShowLocation      func(childComplexity int) int
	}

	PublicProfile struct {
		Bio            func(childComplexity int) int
		ID             func(childComplexity int) int
		Interests      func(childComplexity int) int
		Location       func(childComplexity int) int
		Name           func(childComplexity int) int
		ProfilePicture func(childComplexity int) int
		Skills         func(childComplexity int) int
		VolunteerStats func(childComplexity int) int
	}

	Query struct {
		AttendanceRecords     func(childComplexity int, eventID string) int
		Event                 func(childComplexity int, id string) int
		EventBySlug           func(childComplexity int, slug string) int
		EventRegistrations    func(childComplexity int, eventID string, filter *model.RegistrationFilterInput) int
		EventUpdates          func(childComplexity int, eventID string, first *int, after *string) int
		Events                func(childComplexity int, filter *model.EventSearchFilter, sort *model.EventSortInput, first *int, after *string) int
		Health                func(childComplexity int) int
		Interests             func(childComplexity int) int
		Me                    func(childComplexity int) int
		MyEvents              func(childComplexity int, status []model.EventStatus, first *int, after *string) int
		MyRegistrations       func(childComplexity int, filter *model.RegistrationFilterInput) int
		NearbyEvents          func(childComplexity int, coordinates model.CoordinatesInput, radius float64, filter *model.EventSearchFilter, first *int, after *string) int
		Registration          func(childComplexity int, id string) int
		RegistrationConflicts func(childComplexity int, eventID string) int
		RegistrationStats     func(childComplexity int, eventID string) int
		SearchEvents          func(childComplexity int, query string, filter *model.EventSearchFilter, sort *model.EventSortInput, first *int, after *string) int
		SearchUsers           func(childComplexity int, filter model.UserSearchFilter, limit *int, offset *int) int
		User                  func(childComplexity int, id string) int
		UserActivity          func(childComplexity int) int
		WaitlistEntries       func(childComplexity int, eventID string) int
	}

	RecurrenceRule struct {
		DayOfMonth      func(childComplexity int) int
		DaysOfWeek      func(childComplexity int) int
		EndDate         func(childComplexity int) int
		Frequency       func(childComplexity int) int
		Interval        func(childComplexity int) int
		OccurrenceCount func(childComplexity int) int
	}

	Registration struct {
		AppliedAt          func(childComplexity int) int
		ApprovalNotes      func(childComplexity int) int
		AttendanceStatus   func(childComplexity int) int
		CanCancel          func(childComplexity int) int
		CanCheckIn         func(childComplexity int) int
		CancellationReason func(childComplexity int) int
		CancelledAt        func(childComplexity int) int
		CheckedInAt        func(childComplexity int) int
		CompletedAt        func(childComplexity int) int
		ConfirmedAt        func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		Event              func(childComplexity int) int
		ID                 func(childComplexity int) int
		Interests          func(childComplexity int) int
		PersonalMessage    func(childComplexity int) int
		Skills             func(childComplexity int) int
		Status             func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		User               func(childComplexity int) int
		WaitlistPosition   func(childComplexity int) int
	}

	RegistrationConflict struct {
		ConflictType     func(childComplexity int) int
		ConflictingEvent func(childComplexity int) int
		Severity         func(childComplexity int) int
		Suggestions      func(childComplexity int) int
	}

	RegistrationSettings struct {
		AllowWaitlist        func(childComplexity int) int
		CancellationDeadline func(childComplexity int) int
		ClosesAt             func(childComplexity int) int
		ConfirmationRequired func(childComplexity int) int
		OpensAt              func(childComplexity int) int
		RequiresApproval     func(childComplexity int) int
	}

	RegistrationStats struct {
		AttendanceRate         func(childComplexity int) int
		CancellationRate       func(childComplexity int) int
		ConfirmedRegistrations func(childComplexity int) int
		NoShowRate             func(childComplexity int) int
		TotalRegistrations     func(childComplexity int) int
		WaitlistCount          func(childComplexity int) int
	}

	Skill struct {
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Proficiency func(childComplexity int) int
		Verified    func(childComplexity int) int
	}

	SkillRequirement struct {
		ID          func(childComplexity int) int
		Proficiency func(childComplexity int) int
		Required    func(childComplexity int) int
		Skill       func(childComplexity int) int
	}

	TrainingRequirement struct {
		Description         func(childComplexity int) int
		ID                  func(childComplexity int) int
		Name                func(childComplexity int) int
		ProvidedByOrganizer func(childComplexity int) int
		Required            func(childComplexity int) int
	}

	User struct {
		Bio            func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Email          func(childComplexity int) int
		EmailVerified  func(childComplexity int) int
		GoogleID       func(childComplexity int) int
		ID             func(childComplexity int) int
		Interests      func(childComplexity int) int
		IsVerified     func(childComplexity int) int
		JoinedAt       func(childComplexity int) int
		LastActiveAt   func(childComplexity int) int
		LastLogin      func(childComplexity int) int
		Location       func(childComplexity int) int
		Name           func(childComplexity int) int
		ProfilePicture func(childComplexity int) int
		PublicProfile  func(childComplexity int) int
		Roles          func(childComplexity int) int
		Skills         func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	UserSkill struct {
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Proficiency func(childComplexity int) int
	}

	VolunteerStats struct {
		EventsParticipated func(childComplexity int) int
		Hours              func(childComplexity int) int
	}

	WaitlistEntry struct {
		AutoPromote            func(childComplexity int) int
		EstimatedPromotionTime func(childComplexity int) int
		ID                     func(childComplexity int) int
		Position               func(childComplexity int) int
		PromotionExpiresAt     func(childComplexity int) int
		PromotionOfferedAt     func(childComplexity int) int
		Registration           func(childComplexity int) int
	}
}

type EventResolver interface {
	Organizer(ctx context.Context, obj *model.Event) (*model.User, error)

	Images(ctx context.Context, obj *model.Event) ([]*model.EventImage, error)
	Announcements(ctx context.Context, obj *model.Event) ([]*model.EventAnnouncement, error)

	CurrentRegistrations(ctx context.Context, obj *model.Event) (int, error)
}
type MutationResolver interface {
	Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error)
	Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error)
	RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error)
	Logout(ctx context.Context) (bool, error)
	GoogleAuthURL(ctx context.Context, redirectURL string) (string, error)
	GoogleCallback(ctx context.Context, code string, state string, redirectURL string) (*model.AuthPayload, error)
	UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error)
	UploadProfilePicture(ctx context.Context, file graphql.Upload) (string, error)
	UpdateInterests(ctx context.Context, input model.InterestInput) (*model.User, error)
	AddSkill(ctx context.Context, input model.SkillInput) (*model.User, error)
	RemoveSkill(ctx context.Context, skillID string) (*model.User, error)
	UpdatePrivacySettings(ctx context.Context, input model.PrivacySettingsInput) (*model.User, error)
	UpdateNotificationPreferences(ctx context.Context, input model.NotificationPreferencesInput) (*model.User, error)
	ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error)
	DeactivateAccount(ctx context.Context, confirmationCode string) (bool, error)
	ExportUserData(ctx context.Context) (string, error)
	CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error)
	UpdateEvent(ctx context.Context, id string, input model.UpdateEventInput) (*model.Event, error)
	PublishEvent(ctx context.Context, id string) (*model.Event, error)
	CancelEvent(ctx context.Context, id string, reason *string) (*model.Event, error)
	DeleteEvent(ctx context.Context, id string) (bool, error)
	AddEventImage(ctx context.Context, eventID string, file graphql.Upload, altText *string, isPrimary *bool) (*model.EventImage, error)
	UpdateEventImage(ctx context.Context, id string, altText *string, isPrimary *bool, displayOrder *int) (*model.EventImage, error)
	DeleteEventImage(ctx context.Context, id string) (bool, error)
	CreateEventAnnouncement(ctx context.Context, eventID string, title string, content string, isUrgent *bool) (*model.EventAnnouncement, error)
	UpdateEventAnnouncement(ctx context.Context, id string, title *string, content *string, isUrgent *bool) (*model.EventAnnouncement, error)
	DeleteEventAnnouncement(ctx context.Context, id string) (bool, error)
	RegisterForEvent(ctx context.Context, input model.RegisterForEventInput) (*model.Registration, error)
	BulkRegister(ctx context.Context, input model.BulkRegistrationInput) ([]*model.Registration, error)
	CancelRegistration(ctx context.Context, registrationID string, reason *string) (*model.Registration, error)
	ApproveRegistration(ctx context.Context, input model.ApprovalDecisionInput) (*model.Registration, error)
	CheckInVolunteer(ctx context.Context, input model.AttendanceInput) (*model.AttendanceRecord, error)
	MarkAttendance(ctx context.Context, input model.AttendanceInput) (*model.AttendanceRecord, error)
	PromoteFromWaitlist(ctx context.Context, registrationID string) (*model.Registration, error)
	TransferRegistration(ctx context.Context, registrationID string, newEventID string) (*model.Registration, error)
	UpdateRegistration(ctx context.Context, registrationID string, personalMessage *string) (*model.Registration, error)
}
type PublicProfileResolver interface {
	Interests(ctx context.Context, obj *model.PublicProfile) ([]*model.Interest, error)
	Skills(ctx context.Context, obj *model.PublicProfile) ([]*model.Skill, error)
	VolunteerStats(ctx context.Context, obj *model.PublicProfile) (*model.VolunteerStats, error)
}
type QueryResolver interface {
	Health(ctx context.Context) (*model.Health, error)
	Me(ctx context.Context) (*model.User, error)
	User(ctx context.Context, id string) (*model.PublicProfile, error)
	SearchUsers(ctx context.Context, filter model.UserSearchFilter, limit *int, offset *int) ([]*model.PublicProfile, error)
	Interests(ctx context.Context) ([]*model.Interest, error)
	UserActivity(ctx context.Context) ([]*model.ActivityLog, error)
	Event(ctx context.Context, id string) (*model.Event, error)
	EventBySlug(ctx context.Context, slug string) (*model.Event, error)
	Events(ctx context.Context, filter *model.EventSearchFilter, sort *model.EventSortInput, first *int, after *string) (*model.EventConnection, error)
	SearchEvents(ctx context.Context, query string, filter *model.EventSearchFilter, sort *model.EventSortInput, first *int, after *string) (*model.EventConnection, error)
	MyEvents(ctx context.Context, status []model.EventStatus, first *int, after *string) (*model.EventConnection, error)
	NearbyEvents(ctx context.Context, coordinates model.CoordinatesInput, radius float64, filter *model.EventSearchFilter, first *int, after *string) (*model.EventConnection, error)
	EventUpdates(ctx context.Context, eventID string, first *int, after *string) ([]*model.EventUpdate, error)
	MyRegistrations(ctx context.Context, filter *model.RegistrationFilterInput) ([]*model.Registration, error)
	Registration(ctx context.Context, id string) (*model.Registration, error)
	EventRegistrations(ctx context.Context, eventID string, filter *model.RegistrationFilterInput) ([]*model.Registration, error)
	WaitlistEntries(ctx context.Context, eventID string) ([]*model.WaitlistEntry, error)
	RegistrationConflicts(ctx context.Context, eventID string) ([]*model.RegistrationConflict, error)
	AttendanceRecords(ctx context.Context, eventID string) ([]*model.AttendanceRecord, error)
	RegistrationStats(ctx context.Context, eventID string) (*model.RegistrationStats, error)
}
type RegistrationResolver interface {
	User(ctx context.Context, obj *model.Registration) (*model.User, error)
	Event(ctx context.Context, obj *model.Registration) (*model.Event, error)

	Skills(ctx context.Context, obj *model.Registration) ([]*model.UserSkill, error)
	Interests(ctx context.Context, obj *model.Registration) ([]*model.Interest, error)
}
type UserResolver interface {
	Interests(ctx context.Context, obj *model.User) ([]*model.Interest, error)
	Skills(ctx context.Context, obj *model.User) ([]*model.Skill, error)

	PublicProfile(ctx context.Context, obj *model.User) (*model.PublicProfile, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ActivityLog.action":
		if e.complexity.ActivityLog.Action == nil {
			break
		}

		return e.complexity.ActivityLog.Action(childComplexity), true

	case "ActivityLog.createdAt":
		if e.complexity.ActivityLog.CreatedAt == nil {
			break
		}

		return e.complexity.ActivityLog.CreatedAt(childComplexity), true

	case "ActivityLog.id":
		if e.complexity.ActivityLog.ID == nil {
			break
		}

		return e.complexity.ActivityLog.ID(childComplexity), true

	case "ActivityLog.ipAddress":
		if e.complexity.ActivityLog.IPAddress == nil {
			break
		}

		return e.complexity.ActivityLog.IPAddress(childComplexity), true

	case "ActivityLog.userAgent":
		if e.complexity.ActivityLog.UserAgent == nil {
			break
		}

		return e.complexity.ActivityLog.UserAgent(childComplexity), true

	case "AttendanceRecord.checkedInAt":
		if e.complexity.AttendanceRecord.CheckedInAt == nil {
			break
		}

		return e.complexity.AttendanceRecord.CheckedInAt(childComplexity), true

	case "AttendanceRecord.checkedInBy":
		if e.complexity.AttendanceRecord.CheckedInBy == nil {
			break
		}

		return e.complexity.AttendanceRecord.CheckedInBy(childComplexity), true

	case "AttendanceRecord.notes":
		if e.complexity.AttendanceRecord.Notes == nil {
			break
		}

		return e.complexity.AttendanceRecord.Notes(childComplexity), true

	case "AttendanceRecord.registration":
		if e.complexity.AttendanceRecord.Registration == nil {
			break
		}

		return e.complexity.AttendanceRecord.Registration(childComplexity), true

	case "AuthPayload.refreshToken":
		if e.complexity.AuthPayload.RefreshToken == nil {
			break
		}

		return e.complexity.AuthPayload.RefreshToken(childComplexity), true

	case "AuthPayload.token":
		if e.complexity.AuthPayload.Token == nil {
			break
		}

		return e.complexity.AuthPayload.Token(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "Coordinates.lat":
		if e.complexity.Coordinates.Lat == nil {
			break
		}

		return e.complexity.Coordinates.Lat(childComplexity), true

	case "Coordinates.lng":
		if e.complexity.Coordinates.Lng == nil {
			break
		}

		return e.complexity.Coordinates.Lng(childComplexity), true

	case "Event.announcements":
		if e.complexity.Event.Announcements == nil {
			break
		}

		return e.complexity.Event.Announcements(childComplexity), true

	case "Event.availableSpots":
		if e.complexity.Event.AvailableSpots == nil {
			break
		}

		return e.complexity.Event.AvailableSpots(childComplexity), true

	case "Event.canRegister":
		if e.complexity.Event.CanRegister == nil {
			break
		}

		return e.complexity.Event.CanRegister(childComplexity), true

	case "Event.capacity":
		if e.complexity.Event.Capacity == nil {
			break
		}

		return e.complexity.Event.Capacity(childComplexity), true

	case "Event.category":
		if e.complexity.Event.Category == nil {
			break
		}

		return e.complexity.Event.Category(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.currentRegistrations":
		if e.complexity.Event.CurrentRegistrations == nil {
			break
		}

		return e.complexity.Event.CurrentRegistrations(childComplexity), true

	case "Event.description":
		if e.complexity.Event.Description == nil {
			break
		}

		return e.complexity.Event.Description(childComplexity), true

	case "Event.endTime":
		if e.complexity.Event.EndTime == nil {
			break
		}

		return e.complexity.Event.EndTime(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.images":
		if e.complexity.Event.Images == nil {
			break
		}

		return e.complexity.Event.Images(childComplexity), true

	case "Event.isAtCapacity":
		if e.complexity.Event.IsAtCapacity == nil {
			break
		}

		return e.complexity.Event.IsAtCapacity(childComplexity), true

	case "Event.location":
		if e.complexity.Event.Location == nil {
			break
		}

		return e.complexity.Event.Location(childComplexity), true

	case "Event.organizer":
		if e.complexity.Event.Organizer == nil {
			break
		}

		return e.complexity.Event.Organizer(childComplexity), true

	case "Event.organizerId":
		if e.complexity.Event.OrganizerID == nil {
			break
		}

		return e.complexity.Event.OrganizerID(childComplexity), true

	case "Event.recurrenceRule":
		if e.complexity.Event.RecurrenceRule == nil {
			break
		}

		return e.complexity.Event.RecurrenceRule(childComplexity), true

	case "Event.registrationSettings":
		if e.complexity.Event.RegistrationSettings == nil {
			break
		}

		return e.complexity.Event.RegistrationSettings(childComplexity), true

	case "Event.requirements":
		if e.complexity.Event.Requirements == nil {
			break
		}

		return e.complexity.Event.Requirements(childComplexity), true

	case "Event.shareURL":
		if e.complexity.Event.ShareURL == nil {
			break
		}

		return e.complexity.Event.ShareURL(childComplexity), true

	case "Event.shortDescription":
		if e.complexity.Event.ShortDescription == nil {
			break
		}

		return e.complexity.Event.ShortDescription(childComplexity), true

	case "Event.slug":
		if e.complexity.Event.Slug == nil {
			break
		}

		return e.complexity.Event.Slug(childComplexity), true

	case "Event.startTime":
		if e.complexity.Event.StartTime == nil {
			break
		}

		return e.complexity.Event.StartTime(childComplexity), true

	case "Event.status":
		if e.complexity.Event.Status == nil {
			break
		}

		return e.complexity.Event.Status(childComplexity), true

	case "Event.tags":
		if e.complexity.Event.Tags == nil {
			break
		}

		return e.complexity.Event.Tags(childComplexity), true

	case "Event.timeCommitment":
		if e.complexity.Event.TimeCommitment == nil {
			break
		}

		return e.complexity.Event.TimeCommitment(childComplexity), true

	case "Event.title":
		if e.complexity.Event.Title == nil {
			break
		}

		return e.complexity.Event.Title(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "EventAnnouncement.content":
		if e.complexity.EventAnnouncement.Content == nil {
			break
		}

		return e.complexity.EventAnnouncement.Content(childComplexity), true

	case "EventAnnouncement.createdAt":
		if e.complexity.EventAnnouncement.CreatedAt == nil {
			break
		}

		return e.complexity.EventAnnouncement.CreatedAt(childComplexity), true

	case "EventAnnouncement.id":
		if e.complexity.EventAnnouncement.ID == nil {
			break
		}

		return e.complexity.EventAnnouncement.ID(childComplexity), true

	case "EventAnnouncement.isUrgent":
		if e.complexity.EventAnnouncement.IsUrgent == nil {
			break
		}

		return e.complexity.EventAnnouncement.IsUrgent(childComplexity), true

	case "EventAnnouncement.title":
		if e.complexity.EventAnnouncement.Title == nil {
			break
		}

		return e.complexity.EventAnnouncement.Title(childComplexity), true

	case "EventCapacity.current":
		if e.complexity.EventCapacity.Current == nil {
			break
		}

		return e.complexity.EventCapacity.Current(childComplexity), true

	case "EventCapacity.maximum":
		if e.complexity.EventCapacity.Maximum == nil {
			break
		}

		return e.complexity.EventCapacity.Maximum(childComplexity), true

	case "EventCapacity.minimum":
		if e.complexity.EventCapacity.Minimum == nil {
			break
		}

		return e.complexity.EventCapacity.Minimum(childComplexity), true

	case "EventCapacity.waitlistEnabled":
		if e.complexity.EventCapacity.WaitlistEnabled == nil {
			break
		}

		return e.complexity.EventCapacity.WaitlistEnabled(childComplexity), true

	case "EventConnection.edges":
		if e.complexity.EventConnection.Edges == nil {
			break
		}

		return e.complexity.EventConnection.Edges(childComplexity), true

	case "EventConnection.pageInfo":
		if e.complexity.EventConnection.PageInfo == nil {
			break
		}

		return e.complexity.EventConnection.PageInfo(childComplexity), true

	case "EventConnection.totalCount":
		if e.complexity.EventConnection.TotalCount == nil {
			break
		}

		return e.complexity.EventConnection.TotalCount(childComplexity), true

	case "EventEdge.cursor":
		if e.complexity.EventEdge.Cursor == nil {
			break
		}

		return e.complexity.EventEdge.Cursor(childComplexity), true

	case "EventEdge.node":
		if e.complexity.EventEdge.Node == nil {
			break
		}

		return e.complexity.EventEdge.Node(childComplexity), true

	case "EventImage.altText":
		if e.complexity.EventImage.AltText == nil {
			break
		}

		return e.complexity.EventImage.AltText(childComplexity), true

	case "EventImage.displayOrder":
		if e.complexity.EventImage.DisplayOrder == nil {
			break
		}

		return e.complexity.EventImage.DisplayOrder(childComplexity), true

	case "EventImage.id":
		if e.complexity.EventImage.ID == nil {
			break
		}

		return e.complexity.EventImage.ID(childComplexity), true

	case "EventImage.isPrimary":
		if e.complexity.EventImage.IsPrimary == nil {
			break
		}

		return e.complexity.EventImage.IsPrimary(childComplexity), true

	case "EventImage.url":
		if e.complexity.EventImage.URL == nil {
			break
		}

		return e.complexity.EventImage.URL(childComplexity), true

	case "EventLocation.address":
		if e.complexity.EventLocation.Address == nil {
			break
		}

		return e.complexity.EventLocation.Address(childComplexity), true

	case "EventLocation.city":
		if e.complexity.EventLocation.City == nil {
			break
		}

		return e.complexity.EventLocation.City(childComplexity), true

	case "EventLocation.coordinates":
		if e.complexity.EventLocation.Coordinates == nil {
			break
		}

		return e.complexity.EventLocation.Coordinates(childComplexity), true

	case "EventLocation.country":
		if e.complexity.EventLocation.Country == nil {
			break
		}

		return e.complexity.EventLocation.Country(childComplexity), true

	case "EventLocation.instructions":
		if e.complexity.EventLocation.Instructions == nil {
			break
		}

		return e.complexity.EventLocation.Instructions(childComplexity), true

	case "EventLocation.isRemote":
		if e.complexity.EventLocation.IsRemote == nil {
			break
		}

		return e.complexity.EventLocation.IsRemote(childComplexity), true

	case "EventLocation.name":
		if e.complexity.EventLocation.Name == nil {
			break
		}

		return e.complexity.EventLocation.Name(childComplexity), true

	case "EventLocation.state":
		if e.complexity.EventLocation.State == nil {
			break
		}

		return e.complexity.EventLocation.State(childComplexity), true

	case "EventLocation.zipCode":
		if e.complexity.EventLocation.ZipCode == nil {
			break
		}

		return e.complexity.EventLocation.ZipCode(childComplexity), true

	case "EventRequirements.backgroundCheck":
		if e.complexity.EventRequirements.BackgroundCheck == nil {
			break
		}

		return e.complexity.EventRequirements.BackgroundCheck(childComplexity), true

	case "EventRequirements.interests":
		if e.complexity.EventRequirements.Interests == nil {
			break
		}

		return e.complexity.EventRequirements.Interests(childComplexity), true

	case "EventRequirements.minimumAge":
		if e.complexity.EventRequirements.MinimumAge == nil {
			break
		}

		return e.complexity.EventRequirements.MinimumAge(childComplexity), true

	case "EventRequirements.physicalRequirements":
		if e.complexity.EventRequirements.PhysicalRequirements == nil {
			break
		}

		return e.complexity.EventRequirements.PhysicalRequirements(childComplexity), true

	case "EventRequirements.skills":
		if e.complexity.EventRequirements.Skills == nil {
			break
		}

		return e.complexity.EventRequirements.Skills(childComplexity), true

	case "EventRequirements.training":
		if e.complexity.EventRequirements.Training == nil {
			break
		}

		return e.complexity.EventRequirements.Training(childComplexity), true

	case "EventUpdate.createdAt":
		if e.complexity.EventUpdate.CreatedAt == nil {
			break
		}

		return e.complexity.EventUpdate.CreatedAt(childComplexity), true

	case "EventUpdate.fieldName":
		if e.complexity.EventUpdate.FieldName == nil {
			break
		}

		return e.complexity.EventUpdate.FieldName(childComplexity), true

	case "EventUpdate.id":
		if e.complexity.EventUpdate.ID == nil {
			break
		}

		return e.complexity.EventUpdate.ID(childComplexity), true

	case "EventUpdate.newValue":
		if e.complexity.EventUpdate.NewValue == nil {
			break
		}

		return e.complexity.EventUpdate.NewValue(childComplexity), true

	case "EventUpdate.oldValue":
		if e.complexity.EventUpdate.OldValue == nil {
			break
		}

		return e.complexity.EventUpdate.OldValue(childComplexity), true

	case "EventUpdate.updateType":
		if e.complexity.EventUpdate.UpdateType == nil {
			break
		}

		return e.complexity.EventUpdate.UpdateType(childComplexity), true

	case "EventUpdate.updatedBy":
		if e.complexity.EventUpdate.UpdatedBy == nil {
			break
		}

		return e.complexity.EventUpdate.UpdatedBy(childComplexity), true

	case "Health.status":
		if e.complexity.Health.Status == nil {
			break
		}

		return e.complexity.Health.Status(childComplexity), true

	case "Health.time":
		if e.complexity.Health.Time == nil {
			break
		}

		return e.complexity.Health.Time(childComplexity), true

	case "Interest.category":
		if e.complexity.Interest.Category == nil {
			break
		}

		return e.complexity.Interest.Category(childComplexity), true

	case "Interest.id":
		if e.complexity.Interest.ID == nil {
			break
		}

		return e.complexity.Interest.ID(childComplexity), true

	case "Interest.name":
		if e.complexity.Interest.Name == nil {
			break
		}

		return e.complexity.Interest.Name(childComplexity), true

	case "Location.city":
		if e.complexity.Location.City == nil {
			break
		}

		return e.complexity.Location.City(childComplexity), true

	case "Location.coordinates":
		if e.complexity.Location.Coordinates == nil {
			break
		}

		return e.complexity.Location.Coordinates(childComplexity), true

	case "Location.country":
		if e.complexity.Location.Country == nil {
			break
		}

		return e.complexity.Location.Country(childComplexity), true

	case "Location.state":
		if e.complexity.Location.State == nil {
			break
		}

		return e.complexity.Location.State(childComplexity), true

	case "Mutation.addEventImage":
		if e.complexity.Mutation.AddEventImage == nil {
			break
		}

		args, err := ec.field_Mutation_addEventImage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventImage(childComplexity, args["eventId"].(string), args["file"].(graphql.Upload), args["altText"].(*string), args["isPrimary"].(*bool)), true

	case "Mutation.addSkill":
		if e.complexity.Mutation.AddSkill == nil {
			break
		}

		args, err := ec.field_Mutation_addSkill_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddSkill(childComplexity, args["input"].(model.SkillInput)), true

	case "Mutation.approveRegistration":
		if e.complexity.Mutation.ApproveRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_approveRegistration_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveRegistration(childComplexity, args["input"].(model.ApprovalDecisionInput)), true

	case "Mutation.bulkRegister":
		if e.complexity.Mutation.BulkRegister == nil {
			break
		}

		args, err := ec.field_Mutation_bulkRegister_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkRegister(childComplexity, args["input"].(model.BulkRegistrationInput)), true

	case "Mutation.cancelEvent":
		if e.complexity.Mutation.CancelEvent == nil {
			break
		}

		args, err := ec.field_Mutation_cancelEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelEvent(childComplexity, args["id"].(string), args["reason"].(*string)), true

	case "Mutation.cancelRegistration":
		if e.complexity.Mutation.CancelRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_cancelRegistration_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelRegistration(childComplexity, args["registrationId"].(string), args["reason"].(*string)), true

	case "Mutation.changePassword":
		if e.complexity.Mutation.ChangePassword == nil {
			break
		}

		args, err := ec.field_Mutation_changePassword_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangePassword(childComplexity, args["currentPassword"].(string), args["newPassword"].(string)), true

	case "Mutation.checkInVolunteer":
		if e.complexity.Mutation.CheckInVolunteer == nil {
			break
		}

		args, err := ec.field_Mutation_checkInVolunteer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CheckInVolunteer(childComplexity, args["input"].(model.AttendanceInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(model.CreateEventInput)), true

	case "Mutation.createEventAnnouncement":
		if e.complexity.Mutation.CreateEventAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_createEventAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEventAnnouncement(childComplexity, args["eventId"].(string), args["title"].(string), args["content"].(string), args["isUrgent"].(*bool)), true

	case "Mutation.deactivateAccount":
		if e.complexity.Mutation.DeactivateAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deactivateAccount_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeactivateAccount(childComplexity, args["confirmationCode"].(string)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEventAnnouncement":
		if e.complexity.Mutation.DeleteEventAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventAnnouncement(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEventImage":
		if e.complexity.Mutation.DeleteEventImage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventImage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventImage(childComplexity, args["id"].(string)), true

	case "Mutation.exportUserData":
		if e.complexity.Mutation.ExportUserData == nil {
			break
		}

		return e.complexity.Mutation.ExportUserData(childComplexity), true

	case "Mutation.googleAuthURL":
		if e.complexity.Mutation.GoogleAuthURL == nil {
			break
		}

		args, err := ec.field_Mutation_googleAuthURL_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GoogleAuthURL(childComplexity, args["redirectURL"].(string)), true

	case "Mutation.googleCallback":
		if e.complexity.Mutation.GoogleCallback == nil {
			break
		}

		args, err := ec.field_Mutation_googleCallback_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GoogleCallback(childComplexity, args["code"].(string), args["state"].(string), args["redirectURL"].(string)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.LoginInput)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.markAttendance":
		if e.complexity.Mutation.MarkAttendance == nil {
			break
		}

		args, err := ec.field_Mutation_markAttendance_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarkAttendance(childComplexity, args["input"].(model.AttendanceInput)), true

	case "Mutation.promoteFromWaitlist":
		if e.complexity.Mutation.PromoteFromWaitlist == nil {
			break
		}

		args, err := ec.field_Mutation_promoteFromWaitlist_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PromoteFromWaitlist(childComplexity, args["registrationId"].(string)), true

	case "Mutation.publishEvent":
		if e.complexity.Mutation.PublishEvent == nil {
			break
		}

		args, err := ec.field_Mutation_publishEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PublishEvent(childComplexity, args["id"].(string)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_refreshToken_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshToken(childComplexity, args["input"].(model.RefreshTokenInput)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["input"].(model.RegisterInput)), true

	case "Mutation.registerForEvent":
		if e.complexity.Mutation.RegisterForEvent == nil {
			break
		}

		args, err := ec.field_Mutation_registerForEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterForEvent(childComplexity, args["input"].(model.RegisterForEventInput)), true

	case "Mutation.removeSkill":
		if e.complexity.Mutation.RemoveSkill == nil {
			break
		}

		args, err := ec.field_Mutation_removeSkill_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveSkill(childComplexity, args["skillId"].(string)), true

	case "Mutation.transferRegistration":
		if e.complexity.Mutation.TransferRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_transferRegistration_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TransferRegistration(childComplexity, args["registrationId"].(string), args["newEventId"].(string)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["id"].(string), args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateEventAnnouncement":
		if e.complexity.Mutation.UpdateEventAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventAnnouncement(childComplexity, args["id"].(string), args["title"].(*string), args["content"].(*string), args["isUrgent"].(*bool)), true

	case "Mutation.updateEventImage":
		if e.complexity.Mutation.UpdateEventImage == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventImage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventImage(childComplexity, args["id"].(string), args["altText"].(*string), args["isPrimary"].(*bool), args["displayOrder"].(*int)), true

	case "Mutation.updateInterests":
		if e.complexity.Mutation.UpdateInterests == nil {
			break
		}

		args, err := ec.field_Mutation_updateInterests_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateInterests(childComplexity, args["input"].(model.InterestInput)), true

	case "Mutation.updateNotificationPreferences":
		if e.complexity.Mutation.UpdateNotificationPreferences == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotificationPreferences_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotificationPreferences(childComplexity, args["input"].(model.NotificationPreferencesInput)), true

	case "Mutation.updatePrivacySettings":
		if e.complexity.Mutation.UpdatePrivacySettings == nil {
			break
		}

		args, err := ec.field_Mutation_updatePrivacySettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePrivacySettings(childComplexity, args["input"].(model.PrivacySettingsInput)), true

	case "Mutation.updateProfile":
		if e.complexity.Mutation.UpdateProfile == nil {
			break
		}

		args, err := ec.field_Mutation_updateProfile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProfile(childComplexity, args["input"].(model.UpdateProfileInput)), true

	case "Mutation.updateRegistration":
		if e.complexity.Mutation.UpdateRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_updateRegistration_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRegistration(childComplexity, args["registrationId"].(string), args["personalMessage"].(*string)), true

	case "Mutation.uploadProfilePicture":
		if e.complexity.Mutation.UploadProfilePicture == nil {
			break
		}

		args, err := ec.field_Mutation_uploadProfilePicture_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadProfilePicture(childComplexity, args["file"].(graphql.Upload)), true

	case "NotificationPreferences.emailNotifications":
		if e.complexity.NotificationPreferences.EmailNotifications == nil {
			break
		}

		return e.complexity.NotificationPreferences.EmailNotifications(childComplexity), true

	case "NotificationPreferences.eventReminders":
		if e.complexity.NotificationPreferences.EventReminders == nil {
			break
		}

		return e.complexity.NotificationPreferences.EventReminders(childComplexity), true

	case "NotificationPreferences.newOpportunities":
		if e.complexity.NotificationPreferences.NewOpportunities == nil {
			break
		}

		return e.complexity.NotificationPreferences.NewOpportunities(childComplexity), true

	case "NotificationPreferences.newsletterSubscription":
		if e.complexity.NotificationPreferences.NewsletterSubscription == nil {
			break
		}

		return e.complexity.NotificationPreferences.NewsletterSubscription(childComplexity), true

	case "NotificationPreferences.pushNotifications":
		if e.complexity.NotificationPreferences.PushNotifications == nil {
			break
		}

		return e.complexity.NotificationPreferences.PushNotifications(childComplexity), true

	case "NotificationPreferences.smsNotifications":
		if e.complexity.NotificationPreferences.SmsNotifications == nil {
			break
		}

		return e.complexity.NotificationPreferences.SmsNotifications(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PrivacySettings.allowMessaging":
		if e.complexity.PrivacySettings.AllowMessaging == nil {
			break
		}

		return e.complexity.PrivacySettings.AllowMessaging(childComplexity), true

	case "PrivacySettings.profileVisibility":
		if e.complexity.PrivacySettings.ProfileVisibility == nil {
			break
		}

		return e.complexity.PrivacySettings.ProfileVisibility(childComplexity), true

	case "PrivacySettings.showEmail":
		if e.complexity.PrivacySettings.ShowEmail == nil {
			break
		}

		return e.complexity.PrivacySettings.ShowEmail(childComplexity), true

	case "PrivacySettings.showLocation":
		if e.complexity.PrivacySettings.ShowLocation == nil {
			break
		}

		return e.complexity.PrivacySettings.ShowLocation(childComplexity), true

	case "PublicProfile.bio":
		if e.complexity.PublicProfile.Bio == nil {
			break
		}

		return e.complexity.PublicProfile.Bio(childComplexity), true

	case "PublicProfile.id":
		if e.complexity.PublicProfile.ID == nil {
			break
		}

		return e.complexity.PublicProfile.ID(childComplexity), true

	case "PublicProfile.interests":
		if e.complexity.PublicProfile.Interests == nil {
			break
		}

		return e.complexity.PublicProfile.Interests(childComplexity), true

	case "PublicProfile.location":
		if e.complexity.PublicProfile.Location == nil {
			break
		}

		return e.complexity.PublicProfile.Location(childComplexity), true

	case "PublicProfile.name":
		if e.complexity.PublicProfile.Name == nil {
			break
		}

		return e.complexity.PublicProfile.Name(childComplexity), true

	case "PublicProfile.profilePicture":
		if e.complexity.PublicProfile.ProfilePicture == nil {
			break
		}

		return e.complexity.PublicProfile.ProfilePicture(childComplexity), true

	case "PublicProfile.skills":
		if e.complexity.PublicProfile.Skills == nil {
			break
		}

		return e.complexity.PublicProfile.Skills(childComplexity), true

	case "PublicProfile.volunteerStats":
		if e.complexity.PublicProfile.VolunteerStats == nil {
			break
		}

		return e.complexity.PublicProfile.VolunteerStats(childComplexity), true

	case "Query.attendanceRecords":
		if e.complexity.Query.AttendanceRecords == nil {
			break
		}

		args, err := ec.field_Query_attendanceRecords_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AttendanceRecords(childComplexity, args["eventId"].(string)), true

	case "Query.event":
		if e.complexity.Query.Event == nil {
			break
		}

		args, err := ec.field_Query_event_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Event(childComplexity, args["id"].(string)), true

	case "Query.eventBySlug":
		if e.complexity.Query.EventBySlug == nil {
			break
		}

		args, err := ec.field_Query_eventBySlug_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventBySlug(childComplexity, args["slug"].(string)), true

	case "Query.eventRegistrations":
		if e.complexity.Query.EventRegistrations == nil {
			break
		}

		args, err := ec.field_Query_eventRegistrations_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventRegistrations(childComplexity, args["eventId"].(string), args["filter"].(*model.RegistrationFilterInput)), true

	case "Query.eventUpdates":
		if e.complexity.Query.EventUpdates == nil {
			break
		}

		args, err := ec.field_Query_eventUpdates_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventUpdates(childComplexity, args["eventId"].(string), args["first"].(*int), args["after"].(*string)), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		args, err := ec.field_Query_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Events(childComplexity, args["filter"].(*model.EventSearchFilter), args["sort"].(*model.EventSortInput), args["first"].(*int), args["after"].(*string)), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "Query.interests":
		if e.complexity.Query.Interests == nil {
			break
		}

		return e.complexity.Query.Interests(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.myEvents":
		if e.complexity.Query.MyEvents == nil {
			break
		}

		args, err := ec.field_Query_myEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MyEvents(childComplexity, args["status"].([]model.EventStatus), args["first"].(*int), args["after"].(*string)), true

	case "Query.myRegistrations":
		if e.complexity.Query.MyRegistrations == nil {
			break
		}

		args, err := ec.field_Query_myRegistrations_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MyRegistrations(childComplexity, args["filter"].(*model.RegistrationFilterInput)), true

	case "Query.nearbyEvents":
		if e.complexity.Query.NearbyEvents == nil {
			break
		}

		args, err := ec.field_Query_nearbyEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.NearbyEvents(childComplexity, args["coordinates"].(model.CoordinatesInput), args["radius"].(float64), args["filter"].(*model.EventSearchFilter), args["first"].(*int), args["after"].(*string)), true

	case "Query.registration":
		if e.complexity.Query.Registration == nil {
			break
		}

		args, err := ec.field_Query_registration_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Registration(childComplexity, args["id"].(string)), true

	case "Query.registrationConflicts":
		if e.complexity.Query.RegistrationConflicts == nil {
			break
		}

		args, err := ec.field_Query_registrationConflicts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RegistrationConflicts(childComplexity, args["eventId"].(string)), true

	case "Query.registrationStats":
		if e.complexity.Query.RegistrationStats == nil {
			break
		}

		args, err := ec.field_Query_registrationStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RegistrationStats(childComplexity, args["eventId"].(string)), true

	case "Query.searchEvents":
		if e.complexity.Query.SearchEvents == nil {
			break
		}

		args, err := ec.field_Query_searchEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchEvents(childComplexity, args["query"].(string), args["filter"].(*model.EventSearchFilter), args["sort"].(*model.EventSortInput), args["first"].(*int), args["after"].(*string)), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["filter"].(model.UserSearchFilter), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query.userActivity":
		if e.complexity.Query.UserActivity == nil {
			break
		}

		return e.complexity.Query.UserActivity(childComplexity), true

	case "Query.waitlistEntries":
		if e.complexity.Query.WaitlistEntries == nil {
			break
		}

		args, err := ec.field_Query_waitlistEntries_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WaitlistEntries(childComplexity, args["eventId"].(string)), true

	case "RecurrenceRule.dayOfMonth":
		if e.complexity.RecurrenceRule.DayOfMonth == nil {
			break
		}

		return e.complexity.RecurrenceRule.DayOfMonth(childComplexity), true

	case "RecurrenceRule.daysOfWeek":
		if e.complexity.RecurrenceRule.DaysOfWeek == nil {
			break
		}

		return e.complexity.RecurrenceRule.DaysOfWeek(childComplexity), true

	case "RecurrenceRule.endDate":
		if e.complexity.RecurrenceRule.EndDate == nil {
			break
		}

		return e.complexity.RecurrenceRule.EndDate(childComplexity), true

	case "RecurrenceRule.frequency":
		if e.complexity.RecurrenceRule.Frequency == nil {
			break
		}

		return e.complexity.RecurrenceRule.Frequency(childComplexity), true

	case "RecurrenceRule.interval":
		if e.complexity.RecurrenceRule.Interval == nil {
			break
		}

		return e.complexity.RecurrenceRule.Interval(childComplexity), true

	case "RecurrenceRule.occurrenceCount":
		if e.complexity.RecurrenceRule.OccurrenceCount == nil {
			break
		}

		return e.complexity.RecurrenceRule.OccurrenceCount(childComplexity), true

	case "Registration.appliedAt":
		if e.complexity.Registration.AppliedAt == nil {
			break
		}

		return e.complexity.Registration.AppliedAt(childComplexity), true

	case "Registration.approvalNotes":
		if e.complexity.Registration.ApprovalNotes == nil {
			break
		}

		return e.complexity.Registration.ApprovalNotes(childComplexity), true

	case "Registration.attendanceStatus":
		if e.complexity.Registration.AttendanceStatus == nil {
			break
		}

		return e.complexity.Registration.AttendanceStatus(childComplexity), true

	case "Registration.canCancel":
		if e.complexity.Registration.CanCancel == nil {
			break
		}

		return e.complexity.Registration.CanCancel(childComplexity), true

	case "Registration.canCheckIn":
		if e.complexity.Registration.CanCheckIn == nil {
			break
		}

		return e.complexity.Registration.CanCheckIn(childComplexity), true

	case "Registration.cancellationReason":
		if e.complexity.Registration.CancellationReason == nil {
			break
		}

		return e.complexity.Registration.CancellationReason(childComplexity), true

	case "Registration.cancelledAt":
		if e.complexity.Registration.CancelledAt == nil {
			break
		}

		return e.complexity.Registration.CancelledAt(childComplexity), true

	case "Registration.checkedInAt":
		if e.complexity.Registration.CheckedInAt == nil {
			break
		}

		return e.complexity.Registration.CheckedInAt(childComplexity), true

	case "Registration.completedAt":
		if e.complexity.Registration.CompletedAt == nil {
			break
		}

		return e.complexity.Registration.CompletedAt(childComplexity), true

	case "Registration.confirmedAt":
		if e.complexity.Registration.ConfirmedAt == nil {
			break
		}

		return e.complexity.Registration.ConfirmedAt(childComplexity), true

	case "Registration.createdAt":
		if e.complexity.Registration.CreatedAt == nil {
			break
		}

		return e.complexity.Registration.CreatedAt(childComplexity), true

	case "Registration.event":
		if e.complexity.Registration.Event == nil {
			break
		}

		return e.complexity.Registration.Event(childComplexity), true

	case "Registration.id":
		if e.complexity.Registration.ID == nil {
			break
		}

		return e.complexity.Registration.ID(childComplexity), true

	case "Registration.interests":
		if e.complexity.Registration.Interests == nil {
			break
		}

		return e.complexity.Registration.Interests(childComplexity), true

	case "Registration.personalMessage":
		if e.complexity.Registration.PersonalMessage == nil {
			break
		}

		return e.complexity.Registration.PersonalMessage(childComplexity), true

	case "Registration.skills":
		if e.complexity.Registration.Skills == nil {
			break
		}

		return e.complexity.Registration.Skills(childComplexity), true

	case "Registration.status":
		if e.complexity.Registration.Status == nil {
			break
		}

		return e.complexity.Registration.Status(childComplexity), true

	case "Registration.updatedAt":
		if e.complexity.Registration.UpdatedAt == nil {
			break
		}

		return e.complexity.Registration.UpdatedAt(childComplexity), true

	case "Registration.user":
		if e.complexity.Registration.User == nil {
			break
		}

		return e.complexity.Registration.User(childComplexity), true

	case "Registration.waitlistPosition":
		if e.complexity.Registration.WaitlistPosition == nil {
			break
		}

		return e.complexity.Registration.WaitlistPosition(childComplexity), true

	case "RegistrationConflict.conflictType":
		if e.complexity.RegistrationConflict.ConflictType == nil {
			break
		}

		return e.complexity.RegistrationConflict.ConflictType(childComplexity), true

	case "RegistrationConflict.conflictingEvent":
		if e.complexity.RegistrationConflict.ConflictingEvent == nil {
			break
		}

		return e.complexity.RegistrationConflict.ConflictingEvent(childComplexity), true

	case "RegistrationConflict.severity":
		if e.complexity.RegistrationConflict.Severity == nil {
			break
		}

		return e.complexity.RegistrationConflict.Severity(childComplexity), true

	case "RegistrationConflict.suggestions":
		if e.complexity.RegistrationConflict.Suggestions == nil {
			break
		}

		return e.complexity.RegistrationConflict.Suggestions(childComplexity), true

	case "RegistrationSettings.allowWaitlist":
		if e.complexity.RegistrationSettings.AllowWaitlist == nil {
			break
		}

		return e.complexity.RegistrationSettings.AllowWaitlist(childComplexity), true

	case "RegistrationSettings.cancellationDeadline":
		if e.complexity.RegistrationSettings.CancellationDeadline == nil {
			break
		}

		return e.complexity.RegistrationSettings.CancellationDeadline(childComplexity), true

	case "RegistrationSettings.closesAt":
		if e.complexity.RegistrationSettings.ClosesAt == nil {
			break
		}

		return e.complexity.RegistrationSettings.ClosesAt(childComplexity), true

	case "RegistrationSettings.confirmationRequired":
		if e.complexity.RegistrationSettings.ConfirmationRequired == nil {
			break
		}

		return e.complexity.RegistrationSettings.ConfirmationRequired(childComplexity), true

	case "RegistrationSettings.opensAt":
		if e.complexity.RegistrationSettings.OpensAt == nil {
			break
		}

		return e.complexity.RegistrationSettings.OpensAt(childComplexity), true

	case "RegistrationSettings.requiresApproval":
		if e.complexity.RegistrationSettings.RequiresApproval == nil {
			break
		}

		return e.complexity.RegistrationSettings.RequiresApproval(childComplexity), true

	case "RegistrationStats.attendanceRate":
		if e.complexity.RegistrationStats.AttendanceRate == nil {
			break
		}

		return e.complexity.RegistrationStats.AttendanceRate(childComplexity), true

	case "RegistrationStats.cancellationRate":
		if e.complexity.RegistrationStats.CancellationRate == nil {
			break
		}

		return e.complexity.RegistrationStats.CancellationRate(childComplexity), true

	case "RegistrationStats.confirmedRegistrations":
		if e.complexity.RegistrationStats.ConfirmedRegistrations == nil {
			break
		}

		return e.complexity.RegistrationStats.ConfirmedRegistrations(childComplexity), true

	case "RegistrationStats.noShowRate":
		if e.complexity.RegistrationStats.NoShowRate == nil {
			break
		}

		return e.complexity.RegistrationStats.NoShowRate(childComplexity), true

	case "RegistrationStats.totalRegistrations":
		if e.complexity.RegistrationStats.TotalRegistrations == nil {
			break
		}

		return e.complexity.RegistrationStats.TotalRegistrations(childComplexity), true

	case "RegistrationStats.waitlistCount":
		if e.complexity.RegistrationStats.WaitlistCount == nil {
			break
		}

		return e.complexity.RegistrationStats.WaitlistCount(childComplexity), true

	case "Skill.id":
		if e.complexity.Skill.ID == nil {
			break
		}

		return e.complexity.Skill.ID(childComplexity), true

	case "Skill.name":
		if e.complexity.Skill.Name == nil {
			break
		}

		return e.complexity.Skill.Name(childComplexity), true

	case "Skill.proficiency":
		if e.complexity.Skill.Proficiency == nil {
			break
		}

		return e.complexity.Skill.Proficiency(childComplexity), true

	case "Skill.verified":
		if e.complexity.Skill.Verified == nil {
			break
		}

		return e.complexity.Skill.Verified(childComplexity), true

	case "SkillRequirement.id":
		if e.complexity.SkillRequirement.ID == nil {
			break
		}

		return e.complexity.SkillRequirement.ID(childComplexity), true

	case "SkillRequirement.proficiency":
		if e.complexity.SkillRequirement.Proficiency == nil {
			break
		}

		return e.complexity.SkillRequirement.Proficiency(childComplexity), true

	case "SkillRequirement.required":
		if e.complexity.SkillRequirement.Required == nil {
			break
		}

		return e.complexity.SkillRequirement.Required(childComplexity), true

	case "SkillRequirement.skill":
		if e.complexity.SkillRequirement.Skill == nil {
			break
		}

		return e.complexity.SkillRequirement.Skill(childComplexity), true

	case "TrainingRequirement.description":
		if e.complexity.TrainingRequirement.Description == nil {
			break
		}

		return e.complexity.TrainingRequirement.Description(childComplexity), true

	case "TrainingRequirement.id":
		if e.complexity.TrainingRequirement.ID == nil {
			break
		}

		return e.complexity.TrainingRequirement.ID(childComplexity), true

	case "TrainingRequirement.name":
		if e.complexity.TrainingRequirement.Name == nil {
			break
		}

		return e.complexity.TrainingRequirement.Name(childComplexity), true

	case "TrainingRequirement.providedByOrganizer":
		if e.complexity.TrainingRequirement.ProvidedByOrganizer == nil {
			break
		}

		return e.complexity.TrainingRequirement.ProvidedByOrganizer(childComplexity), true

	case "TrainingRequirement.required":
		if e.complexity.TrainingRequirement.Required == nil {
			break
		}

		return e.complexity.TrainingRequirement.Required(childComplexity), true

	case "User.bio":
		if e.complexity.User.Bio == nil {
			break
		}

		return e.complexity.User.Bio(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.emailVerified":
		if e.complexity.User.EmailVerified == nil {
			break
		}

		return e.complexity.User.EmailVerified(childComplexity), true

	case "User.googleId":
		if e.complexity.User.GoogleID == nil {
			break
		}

		return e.complexity.User.GoogleID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.interests":
		if e.complexity.User.Interests == nil {
			break
		}

		return e.complexity.User.Interests(childComplexity), true

	case "User.isVerified":
		if e.complexity.User.IsVerified == nil {
			break
		}

		return e.complexity.User.IsVerified(childComplexity), true

	case "User.joinedAt":
		if e.complexity.User.JoinedAt == nil {
			break
		}

		return e.complexity.User.JoinedAt(childComplexity), true

	case "User.lastActiveAt":
		if e.complexity.User.LastActiveAt == nil {
			break
		}

		return e.complexity.User.LastActiveAt(childComplexity), true

	case "User.lastLogin":
		if e.complexity.User.LastLogin == nil {
			break
		}

		return e.complexity.User.LastLogin(childComplexity), true

	case "User.location":
		if e.complexity.User.Location == nil {
			break
		}

		return e.complexity.User.Location(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.profilePicture":
		if e.complexity.User.ProfilePicture == nil {
			break
		}

		return e.complexity.User.ProfilePicture(childComplexity), true

	case "User.publicProfile":
		if e.complexity.User.PublicProfile == nil {
			break
		}

		return e.complexity.User.PublicProfile(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.skills":
		if e.complexity.User.Skills == nil {
			break
		}

		return e.complexity.User.Skills(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserSkill.id":
		if e.complexity.UserSkill.ID == nil {
			break
		}

		return e.complexity.UserSkill.ID(childComplexity), true

	case "UserSkill.name":
		if e.complexity.UserSkill.Name == nil {
			break
		}

		return e.complexity.UserSkill.Name(childComplexity), true

	case "UserSkill.proficiency":
		if e.complexity.UserSkill.Proficiency == nil {
			break
		}

		return e.complexity.UserSkill.Proficiency(childComplexity), true

	case "VolunteerStats.eventsParticipated":
		if e.complexity.VolunteerStats.EventsParticipated == nil {
			break
		}

		return e.complexity.VolunteerStats.EventsParticipated(childComplexity), true

	case "VolunteerStats.hours":
		if e.complexity.VolunteerStats.Hours == nil {
			break
		}

		return e.complexity.VolunteerStats.Hours(childComplexity), true

	case "WaitlistEntry.autoPromote":
		if e.complexity.WaitlistEntry.AutoPromote == nil {
			break
		}

		return e.complexity.WaitlistEntry.AutoPromote(childComplexity), true

	case "WaitlistEntry.estimatedPromotionTime":
		if e.complexity.WaitlistEntry.EstimatedPromotionTime == nil {
			break
		}

		return e.complexity.WaitlistEntry.EstimatedPromotionTime(childComplexity), true

	case "WaitlistEntry.id":
		if e.complexity.WaitlistEntry.ID == nil {
			break
		}

		return e.complexity.WaitlistEntry.ID(childComplexity), true

	case "WaitlistEntry.position":
		if e.complexity.WaitlistEntry.Position == nil {
			break
		}

		return e.complexity.WaitlistEntry.Position(childComplexity), true

	case "WaitlistEntry.promotionExpiresAt":
		if e.complexity.WaitlistEntry.PromotionExpiresAt == nil {
			break
		}

		return e.complexity.WaitlistEntry.PromotionExpiresAt(childComplexity), true

	case "WaitlistEntry.promotionOfferedAt":
		if e.complexity.WaitlistEntry.PromotionOfferedAt == nil {
			break
		}

		return e.complexity.WaitlistEntry.PromotionOfferedAt(childComplexity), true

	case "WaitlistEntry.registration":
		if e.complexity.WaitlistEntry.Registration == nil {
			break
		}

		return e.complexity.WaitlistEntry.Registration(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputApprovalDecisionInput,
		ec.unmarshalInputAttendanceInput,
		ec.unmarshalInputBulkRegistrationInput,
		ec.unmarshalInputCoordinatesInput,
		ec.unmarshalInputCreateEventInput,
		ec.unmarshalInputDateRangeInput,
		ec.unmarshalInputEmergencyContactInput,
		ec.unmarshalInputEventCapacityInput,
		ec.unmarshalInputEventLocationInput,
		ec.unmarshalInputEventRequirementsInput,
		ec.unmarshalInputEventSearchFilter,
		ec.unmarshalInputEventSortInput,
		ec.unmarshalInputInterestInput,
		ec.unmarshalInputLocationInput,
		ec.unmarshalInputLocationSearchInput,
		ec.unmarshalInputLoginInput,
		ec.unmarshalInputNotificationPreferencesInput,
		ec.unmarshalInputPrivacySettingsInput,
		ec.unmarshalInputRecurrenceRuleInput,
		ec.unmarshalInputRefreshTokenInput,
		ec.unmarshalInputRegisterForEventInput,
		ec.unmarshalInputRegisterInput,
		ec.unmarshalInputRegistrationFilterInput,
		ec.unmarshalInputRegistrationSettingsInput,
		ec.unmarshalInputSkillInput,
		ec.unmarshalInputSkillRequirementInput,
		ec.unmarshalInputTrainingRequirementInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateProfileInput,
		ec.unmarshalInputUserSearchFilter,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `scalar Time
scalar Upload

type Health {
  status: String!
  time: Time!
}

# Authentication Types
type User {
  id: ID!
  email: String!
  name: String!
  emailVerified: Boolean!
  googleId: String
  lastLogin: Time
  createdAt: Time!
  updatedAt: Time!

  # Phase 3 fields
  bio: String
  location: Location
  profilePicture: String
  interests: [Interest!]!
  skills: [Skill!]!
  roles: [String!]!
  isVerified: Boolean!
  joinedAt: Time!
  lastActiveAt: Time
  publicProfile: PublicProfile!
}

type AuthPayload {
  token: String!
  refreshToken: String!
  user: User!
}

# Event Management - Phase 4

# Core Event Types
type Event {
  id: ID!
  title: String!
  description: String!
  shortDescription: String
  organizer: User!
  organizerId: ID!
  status: EventStatus!
  startTime: Time!
  endTime: Time!
  location: EventLocation!
  capacity: EventCapacity!
  requirements: EventRequirements!
  category: EventCategory!
  timeCommitment: TimeCommitmentType!
  tags: [String!]!
  slug: String
  shareURL: String
  recurrenceRule: RecurrenceRule
  registrationSettings: RegistrationSettings!
  images: [EventImage!]!
  announcements: [EventAnnouncement!]!
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  currentRegistrations: Int!
  availableSpots: Int!
  isAtCapacity: Boolean!
  canRegister: Boolean!
}

type EventLocation {
  name: String!
  address: String!
  city: String!
  state: String
  country: String!
  zipCode: String
  coordinates: Coordinates
  instructions: String
  isRemote: Boolean!
}

type EventCapacity {
  minimum: Int!
  maximum: Int!
  current: Int!
  waitlistEnabled: Boolean!
}

type EventRequirements {
  minimumAge: Int
  backgroundCheck: Boolean!
  physicalRequirements: String
  skills: [SkillRequirement!]!
  training: [TrainingRequirement!]!
  interests: [String!]!
}

type SkillRequirement {
  id: ID!
  skill: String!
  proficiency: SkillProficiency!
  required: Boolean!
}

type TrainingRequirement {
  id: ID!
  name: String!
  description: String
  required: Boolean!
  providedByOrganizer: Boolean!
}

type RecurrenceRule {
  frequency: RecurrenceFrequency!
  interval: Int!
  daysOfWeek: [DayOfWeek!]
  dayOfMonth: Int
  endDate: Time
  occurrenceCount: Int
}

type RegistrationSettings {
  opensAt: Time
  closesAt: Time!
  requiresApproval: Boolean!
  allowWaitlist: Boolean!
  confirmationRequired: Boolean!
  cancellationDeadline: Time
}

type EventImage {
  id: ID!
  url: String!
  altText: String
  isPrimary: Boolean!
  displayOrder: Int!
}

type EventAnnouncement {
  id: ID!
  title: String!
  content: String!
  isUrgent: Boolean!
  createdAt: Time!
}

type EventUpdate {
  id: ID!
  updatedBy: User!
  fieldName: String!
  oldValue: String
  newValue: String
  updateType: UpdateType!
  createdAt: Time!
}

# Connection Types for Pagination
type EventConnection {
  edges: [EventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EventEdge {
  node: Event!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Input Types
input CreateEventInput {
  title: String!
  description: String!
  shortDescription: String
  startTime: Time!
  endTime: Time!
  location: EventLocationInput!
  capacity: EventCapacityInput!
  requirements: EventRequirementsInput
  tags: [String!]
  category: EventCategory!
  timeCommitment: TimeCommitmentType!
  recurrenceRule: RecurrenceRuleInput
  registrationSettings: RegistrationSettingsInput!
}

input UpdateEventInput {
  title: String
  description: String
  shortDescription: String
  location: EventLocationInput
  requirements: EventRequirementsInput
  tags: [String!]
  category: EventCategory
}

input EventLocationInput {
  name: String!
  address: String!
  city: String!
  state: String
  country: String!
  zipCode: String
  coordinates: CoordinatesInput
  instructions: String
  isRemote: Boolean!
}

input CoordinatesInput {
  lat: Float!
  lng: Float!
}

input EventCapacityInput {
  minimum: Int!
  maximum: Int!
  waitlistEnabled: Boolean!
}

input EventRequirementsInput {
  minimumAge: Int
  backgroundCheck: Boolean!
  physicalRequirements: String
  skills: [SkillRequirementInput!]
  training: [TrainingRequirementInput!]
  interests: [String!]
}

input SkillRequirementInput {
  skill: String!
  proficiency: SkillProficiency!
  required: Boolean!
}

input TrainingRequirementInput {
  name: String!
  description: String
  required: Boolean!
  providedByOrganizer: Boolean!
}

input RecurrenceRuleInput {
  frequency: RecurrenceFrequency!
  interval: Int!
  daysOfWeek: [DayOfWeek!]
  dayOfMonth: Int
  endDate: Time
  occurrenceCount: Int
}

input RegistrationSettingsInput {
  opensAt: Time
  closesAt: Time!
  requiresApproval: Boolean!
  allowWaitlist: Boolean!
  confirmationRequired: Boolean!
  cancellationDeadline: Time
}

input EventSearchFilter {
  query: String
  status: [EventStatus!]
  category: [EventCategory!]
  timeCommitment: [TimeCommitmentType!]
  organizerId: ID
  tags: [String!]
  startDate: Time
  endDate: Time
  location: LocationSearchInput
  skills: [String!]
  interests: [String!]
  requiresBackgroundCheck: Boolean
  minimumAge: Int
}

input LocationSearchInput {
  city: String
  state: String
  country: String
  radius: Float
  coordinates: CoordinatesInput
}

input EventSortInput {
  field: EventSortField!
  direction: SortDirection!
}

# Enums
enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
  ARCHIVED
}

enum EventCategory {
  COMMUNITY_SERVICE
  ENVIRONMENTAL
  EDUCATION
  HEALTH_WELLNESS
  DISASTER_RELIEF
  ANIMAL_WELFARE
  ARTS_CULTURE
  TECHNOLOGY
  SPORTS_RECREATION
  FOOD_HUNGER
  YOUTH_DEVELOPMENT
  SENIOR_CARE
  HOMELESS_SERVICES
  FUNDRAISING
  ADVOCACY
  OTHER
}

enum TimeCommitmentType {
  ONE_TIME
  WEEKLY
  MONTHLY
  SEASONAL
  ONGOING
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum DayOfWeek {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

enum UpdateType {
  CREATED
  UPDATED
  PUBLISHED
  CANCELLED
  COMPLETED
}

enum EventSortField {
  CREATED_AT
  START_TIME
  TITLE
  CAPACITY
  REGISTRATION_COUNT
}

enum SortDirection {
  ASC
  DESC
}

# Phase 3 types
type PublicProfile {
  id: ID!
  name: String!
  bio: String
  location: Location
  profilePicture: String
  interests: [Interest!]!
  skills: [Skill!]!
  volunteerStats: VolunteerStats!
}

type VolunteerStats {
  hours: Int!
  eventsParticipated: Int!
}

type Interest {
  id: ID!
  name: String!
  category: InterestCategory!
}

type Skill {
  id: ID!
  name: String!
  proficiency: SkillProficiency!
  verified: Boolean!
}

type Location {
  city: String
  state: String
  country: String
  coordinates: Coordinates
}

type Coordinates {
  lat: Float!
  lng: Float!
}

type PrivacySettings {
  profileVisibility: ProfileVisibility!
  showEmail: Boolean!
  showLocation: Boolean!
  allowMessaging: Boolean!
}

type NotificationPreferences {
  emailNotifications: Boolean!
  pushNotifications: Boolean!
  smsNotifications: Boolean!
  eventReminders: Boolean!
  newOpportunities: Boolean!
  newsletterSubscription: Boolean!
}

# Input Types
input RegisterInput {
  name: String!
  email: String!
  password: String!
}

input LoginInput {
  email: String!
  password: String!
}

input RefreshTokenInput {
  refreshToken: String!
}

# Phase 3 inputs
input UpdateProfileInput {
  name: String
  bio: String
  location: LocationInput
}

input LocationInput {
  city: String
  state: String
  country: String
  lat: Float
  lng: Float
}

input InterestInput {
  interestIds: [ID!]!
}

input SkillInput {
  name: String!
  proficiency: SkillProficiency!
}

input PrivacySettingsInput {
  profileVisibility: ProfileVisibility
  showEmail: Boolean
  showLocation: Boolean
  allowMessaging: Boolean
}

input NotificationPreferencesInput {
  emailNotifications: Boolean
  pushNotifications: Boolean
  smsNotifications: Boolean
  eventReminders: Boolean
  newOpportunities: Boolean
  newsletterSubscription: Boolean
}

input UserSearchFilter {
  skills: [String!]
  interests: [ID!]
  location: LocationInput
  availability: AvailabilityStatus
  experience: ExperienceLevel
}

enum AvailabilityStatus {
  AVAILABLE
  BUSY
  AWAY
}

enum ExperienceLevel {
  JUNIOR
  MID
  SENIOR
}

enum ProfileVisibility {
  PUBLIC
  VOLUNTEERS_ONLY
  PRIVATE
}

enum SkillProficiency {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum InterestCategory {
  ENVIRONMENT
  EDUCATION
  HEALTH
  COMMUNITY
  TECHNOLOGY
  ARTS
  SPORTS
  ANIMALS
}

type Query {
  health: Health!
  # Authentication Query
  me: User
  # Phase 3 Queries
  user(id: ID!): PublicProfile
  searchUsers(
    filter: UserSearchFilter!
    limit: Int
    offset: Int
  ): [PublicProfile!]!
  interests: [Interest!]!
  userActivity: [ActivityLog!]!

  # Event Management Queries - Phase 4
  event(id: ID!): Event
  eventBySlug(slug: String!): Event
  events(
    filter: EventSearchFilter
    sort: EventSortInput
    first: Int
    after: String
  ): EventConnection!
  searchEvents(
    query: String!
    filter: EventSearchFilter
    sort: EventSortInput
    first: Int
    after: String
  ): EventConnection!
  myEvents(status: [EventStatus!], first: Int, after: String): EventConnection!
  nearbyEvents(
    coordinates: CoordinatesInput!
    radius: Float!
    filter: EventSearchFilter
    first: Int
    after: String
  ): EventConnection!
  eventUpdates(eventId: ID!, first: Int, after: String): [EventUpdate!]!
}

type Mutation {
  # Authentication Mutations
  register(input: RegisterInput!): AuthPayload!
  login(input: LoginInput!): AuthPayload!
  refreshToken(input: RefreshTokenInput!): AuthPayload!
  logout: Boolean!

  # Google OAuth URLs and callback
  googleAuthURL(redirectURL: String!): String!
  googleCallback(
    code: String!
    state: String!
    redirectURL: String!
  ): AuthPayload!

  # Phase 3 Mutations
  updateProfile(input: UpdateProfileInput!): User!
  uploadProfilePicture(file: Upload!): String!
  updateInterests(input: InterestInput!): User!
  addSkill(input: SkillInput!): User!
  removeSkill(skillId: ID!): User!
  updatePrivacySettings(input: PrivacySettingsInput!): User!
  updateNotificationPreferences(input: NotificationPreferencesInput!): User!
  changePassword(currentPassword: String!, newPassword: String!): Boolean!
  deactivateAccount(confirmationCode: String!): Boolean!
  exportUserData: String!

  # Event Management Mutations - Phase 4
  createEvent(input: CreateEventInput!): Event!
  updateEvent(id: ID!, input: UpdateEventInput!): Event!
  publishEvent(id: ID!): Event!
  cancelEvent(id: ID!, reason: String): Event!
  deleteEvent(id: ID!): Boolean!

  # Event Images
  addEventImage(
    eventId: ID!
    file: Upload!
    altText: String
    isPrimary: Boolean
  ): EventImage!
  updateEventImage(
    id: ID!
    altText: String
    isPrimary: Boolean
    displayOrder: Int
  ): EventImage!
  deleteEventImage(id: ID!): Boolean!

  # Event Announcements
  createEventAnnouncement(
    eventId: ID!
    title: String!
    content: String!
    isUrgent: Boolean
  ): EventAnnouncement!
  updateEventAnnouncement(
    id: ID!
    title: String
    content: String
    isUrgent: Boolean
  ): EventAnnouncement!
  deleteEventAnnouncement(id: ID!): Boolean!

  # Registration mutations
  registerForEvent(input: RegisterForEventInput!): Registration!
  bulkRegister(input: BulkRegistrationInput!): [Registration!]!
  cancelRegistration(registrationId: ID!, reason: String): Registration!
  approveRegistration(input: ApprovalDecisionInput!): Registration!
  checkInVolunteer(input: AttendanceInput!): AttendanceRecord!
  markAttendance(input: AttendanceInput!): AttendanceRecord!
  promoteFromWaitlist(registrationId: ID!): Registration!
  transferRegistration(registrationId: ID!, newEventId: ID!): Registration!
  updateRegistration(
    registrationId: ID!
    personalMessage: String
  ): Registration!
}

# Registration Types
type Registration {
  id: ID!
  user: User!
  event: Event!
  status: RegistrationStatus!
  personalMessage: String
  skills: [UserSkill!]!
  interests: [Interest!]!
  appliedAt: DateTime!
  confirmedAt: DateTime
  cancelledAt: DateTime
  checkedInAt: DateTime
  completedAt: DateTime
  waitlistPosition: Int
  approvalNotes: String
  cancellationReason: String
  attendanceStatus: AttendanceStatus!
  canCancel: Boolean!
  canCheckIn: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WaitlistEntry {
  id: ID!
  registration: Registration!
  position: Int!
  estimatedPromotionTime: DateTime
  promotionOfferedAt: DateTime
  promotionExpiresAt: DateTime
  autoPromote: Boolean!
}

type RegistrationConflict {
  conflictingEvent: Event!
  conflictType: ConflictType!
  severity: ConflictSeverity!
  suggestions: [Event!]!
}

type AttendanceRecord {
  registration: Registration!
  checkedInAt: DateTime
  checkedInBy: User
  notes: String
}

# Input Types
input RegisterForEventInput {
  eventId: ID!
  personalMessage: String
  emergencyContact: EmergencyContactInput
  dietaryRestrictions: String
  accessibilityNeeds: String
}

input BulkRegistrationInput {
  eventIds: [ID!]!
  personalMessage: String
  skipConflicts: Boolean
}

input ApprovalDecisionInput {
  registrationId: ID!
  approved: Boolean!
  notes: String
  conditions: [String!]
}

input AttendanceInput {
  registrationId: ID!
  status: AttendanceStatus!
  notes: String
  checkedInAt: DateTime
}

input RegistrationFilterInput {
  eventId: ID
  userId: ID
  status: [RegistrationStatus!]
  dateRange: DateRangeInput
  attendanceStatus: [AttendanceStatus!]
}

# Enums
enum RegistrationStatus {
  PENDING_APPROVAL
  CONFIRMED
  WAITLISTED
  CANCELLED
  DECLINED
  NO_SHOW
  COMPLETED
}

enum AttendanceStatus {
  REGISTERED
  CHECKED_IN
  COMPLETED
  NO_SHOW
  CANCELLED
}

enum ConflictType {
  TIME_OVERLAP
  LOCATION_CONFLICT
  TRAVEL_TIME_CONFLICT
  SKILL_OVERCOMMITMENT
}

enum ConflictSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type RegistrationStats {
  totalRegistrations: Int!
  confirmedRegistrations: Int!
  waitlistCount: Int!
  attendanceRate: Float!
  noShowRate: Float!
  cancellationRate: Float!
}


extend type Query {
  myRegistrations(filter: RegistrationFilterInput): [Registration!]!
  registration(id: ID!): Registration
  eventRegistrations(
    eventId: ID!
    filter: RegistrationFilterInput
  ): [Registration!]!
  waitlistEntries(eventId: ID!): [WaitlistEntry!]!
  registrationConflicts(eventId: ID!): [RegistrationConflict!]!
  attendanceRecords(eventId: ID!): [AttendanceRecord!]!
  registrationStats(eventId: ID!): RegistrationStats!
}

input EmergencyContactInput {
    name: String!
    phone: String!
}

# Additional types used by queries
type ActivityLog {
  id: ID!
  action: String!
  ipAddress: String
  userAgent: String
  createdAt: Time!
}

scalar DateTime

# A custom type for user skills to be used in the Registration type
type UserSkill {
  id: ID!
  name: String!
  proficiency: SkillProficiency!
}

# A custom input type for date ranges
input DateRangeInput {
  start: DateTime!
  end: DateTime!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addEventImage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "file", ec.unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload)
	if err != nil {
		return nil, err
	}
	args["file"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "altText", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["altText"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "isPrimary", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["isPrimary"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_addSkill_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNSkillInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveRegistration_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNApprovalDecisionInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐApprovalDecisionInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkRegister_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkRegistrationInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐBulkRegistrationInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "reason", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["reason"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelRegistration_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "registrationId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["registrationId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "reason", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["reason"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_changePassword_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "currentPassword", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["currentPassword"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "newPassword", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_checkInVolunteer_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNAttendanceInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createEventAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "title", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["title"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "content", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["content"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "isUrgent", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["isUrgent"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateEventInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCreateEventInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deactivateAccount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "confirmationCode", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["confirmationCode"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEventAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEventImage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_googleAuthURL_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "redirectURL", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["redirectURL"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_googleCallback_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "code", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["code"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "state", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["state"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "redirectURL", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["redirectURL"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_login_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNLoginInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLoginInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_markAttendance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNAttendanceInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_promoteFromWaitlist_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "registrationId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["registrationId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_publishEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshToken_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNRefreshTokenInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRefreshTokenInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerForEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNRegisterForEventInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegisterForEventInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_register_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNRegisterInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegisterInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeSkill_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "skillId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["skillId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_transferRegistration_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "registrationId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["registrationId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "newEventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["newEventId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEventAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "title", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["title"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "content", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["content"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "isUrgent", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["isUrgent"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEventImage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "altText", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["altText"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "isPrimary", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["isPrimary"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "displayOrder", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["displayOrder"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateEventInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateEventInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateInterests_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNInterestInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateNotificationPreferences_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNNotificationPreferencesInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐNotificationPreferencesInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePrivacySettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNPrivacySettingsInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPrivacySettingsInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateProfile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateProfileInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateProfileInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRegistration_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "registrationId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["registrationId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "personalMessage", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["personalMessage"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_uploadProfilePicture_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "file", ec.unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload)
	if err != nil {
		return nil, err
	}
	args["file"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attendanceRecords_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_eventBySlug_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "slug", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["slug"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_eventRegistrations_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalORegistrationFilterInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_eventUpdates_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_event_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOEventSearchFilter2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSearchFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "sort", ec.unmarshalOEventSortInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSortInput)
	if err != nil {
		return nil, err
	}
	args["sort"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["after"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_myEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "status", ec.unmarshalOEventStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatusᚄ)
	if err != nil {
		return nil, err
	}
	args["status"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_myRegistrations_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalORegistrationFilterInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nearbyEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "coordinates", ec.unmarshalNCoordinatesInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinatesInput)
	if err != nil {
		return nil, err
	}
	args["coordinates"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "radius", ec.unmarshalNFloat2float64)
	if err != nil {
		return nil, err
	}
	args["radius"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOEventSearchFilter2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSearchFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["after"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_registrationConflicts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_registrationStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_registration_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_searchEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "query", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["query"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOEventSearchFilter2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSearchFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "sort", ec.unmarshalOEventSortInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSortInput)
	if err != nil {
		return nil, err
	}
	args["sort"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "first", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["first"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["after"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_searchUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalNUserSearchFilter2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUserSearchFilter)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_waitlistEntries_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "eventId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["eventId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActivityLog_id(ctx context.Context, field graphql.CollectedField, obj *model.ActivityLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLog_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLog_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLog_action(ctx context.Context, field graphql.CollectedField, obj *model.ActivityLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLog_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLog_action(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLog_ipAddress(ctx context.Context, field graphql.CollectedField, obj *model.ActivityLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLog_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLog_ipAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLog_userAgent(ctx context.Context, field graphql.CollectedField, obj *model.ActivityLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLog_userAgent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserAgent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLog_userAgent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActivityLog_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ActivityLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActivityLog_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActivityLog_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActivityLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AttendanceRecord_registration(ctx context.Context, field graphql.CollectedField, obj *model.AttendanceRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AttendanceRecord_registration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Registration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AttendanceRecord_registration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AttendanceRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AttendanceRecord_checkedInAt(ctx context.Context, field graphql.CollectedField, obj *model.AttendanceRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AttendanceRecord_checkedInAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedInAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AttendanceRecord_checkedInAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AttendanceRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AttendanceRecord_checkedInBy(ctx context.Context, field graphql.CollectedField, obj *model.AttendanceRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AttendanceRecord_checkedInBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedInBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AttendanceRecord_checkedInBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AttendanceRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AttendanceRecord_notes(ctx context.Context, field graphql.CollectedField, obj *model.AttendanceRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AttendanceRecord_notes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AttendanceRecord_notes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AttendanceRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_token(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_refreshToken(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_refreshToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coordinates_lat(ctx context.Context, field graphql.CollectedField, obj *model.Coordinates) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coordinates_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coordinates_lat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coordinates",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coordinates_lng(ctx context.Context, field graphql.CollectedField, obj *model.Coordinates) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coordinates_lng(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lng, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coordinates_lng(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coordinates",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_title(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_description(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_shortDescription(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_shortDescription(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_shortDescription(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_organizer(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_organizer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Organizer(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_organizer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_organizerId(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_organizerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_organizerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_status(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventStatus)
	fc.Result = res
	return ec.marshalNEventStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_startTime(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_endTime(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_endTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_location(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventLocation)
	fc.Result = res
	return ec.marshalNEventLocation2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_location(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_EventLocation_name(ctx, field)
			case "address":
				return ec.fieldContext_EventLocation_address(ctx, field)
			case "city":
				return ec.fieldContext_EventLocation_city(ctx, field)
			case "state":
				return ec.fieldContext_EventLocation_state(ctx, field)
			case "country":
				return ec.fieldContext_EventLocation_country(ctx, field)
			case "zipCode":
				return ec.fieldContext_EventLocation_zipCode(ctx, field)
			case "coordinates":
				return ec.fieldContext_EventLocation_coordinates(ctx, field)
			case "instructions":
				return ec.fieldContext_EventLocation_instructions(ctx, field)
			case "isRemote":
				return ec.fieldContext_EventLocation_isRemote(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_capacity(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventCapacity)
	fc.Result = res
	return ec.marshalNEventCapacity2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCapacity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "minimum":
				return ec.fieldContext_EventCapacity_minimum(ctx, field)
			case "maximum":
				return ec.fieldContext_EventCapacity_maximum(ctx, field)
			case "current":
				return ec.fieldContext_EventCapacity_current(ctx, field)
			case "waitlistEnabled":
				return ec.fieldContext_EventCapacity_waitlistEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventCapacity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_requirements(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_requirements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requirements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventRequirements)
	fc.Result = res
	return ec.marshalNEventRequirements2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventRequirements(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_requirements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "minimumAge":
				return ec.fieldContext_EventRequirements_minimumAge(ctx, field)
			case "backgroundCheck":
				return ec.fieldContext_EventRequirements_backgroundCheck(ctx, field)
			case "physicalRequirements":
				return ec.fieldContext_EventRequirements_physicalRequirements(ctx, field)
			case "skills":
				return ec.fieldContext_EventRequirements_skills(ctx, field)
			case "training":
				return ec.fieldContext_EventRequirements_training(ctx, field)
			case "interests":
				return ec.fieldContext_EventRequirements_interests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRequirements", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_category(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventCategory)
	fc.Result = res
	return ec.marshalNEventCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_timeCommitment(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_timeCommitment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeCommitment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TimeCommitmentType)
	fc.Result = res
	return ec.marshalNTimeCommitmentType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_timeCommitment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TimeCommitmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_tags(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_slug(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_slug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_slug(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_shareURL(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_shareURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShareURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_shareURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_recurrenceRule(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_recurrenceRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecurrenceRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RecurrenceRule)
	fc.Result = res
	return ec.marshalORecurrenceRule2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_recurrenceRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "frequency":
				return ec.fieldContext_RecurrenceRule_frequency(ctx, field)
			case "interval":
				return ec.fieldContext_RecurrenceRule_interval(ctx, field)
			case "daysOfWeek":
				return ec.fieldContext_RecurrenceRule_daysOfWeek(ctx, field)
			case "dayOfMonth":
				return ec.fieldContext_RecurrenceRule_dayOfMonth(ctx, field)
			case "endDate":
				return ec.fieldContext_RecurrenceRule_endDate(ctx, field)
			case "occurrenceCount":
				return ec.fieldContext_RecurrenceRule_occurrenceCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecurrenceRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_registrationSettings(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_registrationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegistrationSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegistrationSettings)
	fc.Result = res
	return ec.marshalNRegistrationSettings2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_registrationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "opensAt":
				return ec.fieldContext_RegistrationSettings_opensAt(ctx, field)
			case "closesAt":
				return ec.fieldContext_RegistrationSettings_closesAt(ctx, field)
			case "requiresApproval":
				return ec.fieldContext_RegistrationSettings_requiresApproval(ctx, field)
			case "allowWaitlist":
				return ec.fieldContext_RegistrationSettings_allowWaitlist(ctx, field)
			case "confirmationRequired":
				return ec.fieldContext_RegistrationSettings_confirmationRequired(ctx, field)
			case "cancellationDeadline":
				return ec.fieldContext_RegistrationSettings_cancellationDeadline(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegistrationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_images(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EventImage)
	fc.Result = res
	return ec.marshalNEventImage2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventImage_id(ctx, field)
			case "url":
				return ec.fieldContext_EventImage_url(ctx, field)
			case "altText":
				return ec.fieldContext_EventImage_altText(ctx, field)
			case "isPrimary":
				return ec.fieldContext_EventImage_isPrimary(ctx, field)
			case "displayOrder":
				return ec.fieldContext_EventImage_displayOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_announcements(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Announcements(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EventAnnouncement)
	fc.Result = res
	return ec.marshalNEventAnnouncement2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_announcements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventAnnouncement_id(ctx, field)
			case "title":
				return ec.fieldContext_EventAnnouncement_title(ctx, field)
			case "content":
				return ec.fieldContext_EventAnnouncement_content(ctx, field)
			case "isUrgent":
				return ec.fieldContext_EventAnnouncement_isUrgent(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventAnnouncement_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventAnnouncement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_currentRegistrations(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_currentRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().CurrentRegistrations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_currentRegistrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_availableSpots(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_availableSpots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableSpots, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_availableSpots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_isAtCapacity(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_isAtCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAtCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_isAtCapacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_canRegister(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_canRegister(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanRegister, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_canRegister(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventAnnouncement_id(ctx context.Context, field graphql.CollectedField, obj *model.EventAnnouncement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventAnnouncement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventAnnouncement_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventAnnouncement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventAnnouncement_title(ctx context.Context, field graphql.CollectedField, obj *model.EventAnnouncement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventAnnouncement_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventAnnouncement_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventAnnouncement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventAnnouncement_content(ctx context.Context, field graphql.CollectedField, obj *model.EventAnnouncement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventAnnouncement_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventAnnouncement_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventAnnouncement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventAnnouncement_isUrgent(ctx context.Context, field graphql.CollectedField, obj *model.EventAnnouncement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventAnnouncement_isUrgent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsUrgent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventAnnouncement_isUrgent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventAnnouncement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventAnnouncement_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.EventAnnouncement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventAnnouncement_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventAnnouncement_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventAnnouncement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventCapacity_minimum(ctx context.Context, field graphql.CollectedField, obj *model.EventCapacity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventCapacity_minimum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minimum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventCapacity_minimum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventCapacity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventCapacity_maximum(ctx context.Context, field graphql.CollectedField, obj *model.EventCapacity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventCapacity_maximum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maximum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventCapacity_maximum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventCapacity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventCapacity_current(ctx context.Context, field graphql.CollectedField, obj *model.EventCapacity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventCapacity_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Current, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventCapacity_current(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventCapacity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventCapacity_waitlistEnabled(ctx context.Context, field graphql.CollectedField, obj *model.EventCapacity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventCapacity_waitlistEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitlistEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventCapacity_waitlistEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventCapacity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.EventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EventEdge)
	fc.Result = res
	return ec.marshalNEventEdge2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_EventEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_EventEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.EventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.EventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.EventEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.EventEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventImage_id(ctx context.Context, field graphql.CollectedField, obj *model.EventImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventImage_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventImage_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventImage_url(ctx context.Context, field graphql.CollectedField, obj *model.EventImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventImage_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventImage_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventImage_altText(ctx context.Context, field graphql.CollectedField, obj *model.EventImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventImage_altText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AltText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventImage_altText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventImage_isPrimary(ctx context.Context, field graphql.CollectedField, obj *model.EventImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventImage_isPrimary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrimary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventImage_isPrimary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventImage_displayOrder(ctx context.Context, field graphql.CollectedField, obj *model.EventImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventImage_displayOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventImage_displayOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_name(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_address(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_city(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.City, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_city(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_state(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_country(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_country(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_country(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_zipCode(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_zipCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZipCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_zipCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_coordinates(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_coordinates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coordinates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Coordinates)
	fc.Result = res
	return ec.marshalOCoordinates2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinates(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_coordinates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lat":
				return ec.fieldContext_Coordinates_lat(ctx, field)
			case "lng":
				return ec.fieldContext_Coordinates_lng(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Coordinates", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_instructions(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_instructions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Instructions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_instructions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLocation_isRemote(ctx context.Context, field graphql.CollectedField, obj *model.EventLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLocation_isRemote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLocation_isRemote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRequirements_minimumAge(ctx context.Context, field graphql.CollectedField, obj *model.EventRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRequirements_minimumAge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumAge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRequirements_minimumAge(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRequirements_backgroundCheck(ctx context.Context, field graphql.CollectedField, obj *model.EventRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRequirements_backgroundCheck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackgroundCheck, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRequirements_backgroundCheck(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRequirements_physicalRequirements(ctx context.Context, field graphql.CollectedField, obj *model.EventRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRequirements_physicalRequirements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhysicalRequirements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRequirements_physicalRequirements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRequirements_skills(ctx context.Context, field graphql.CollectedField, obj *model.EventRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRequirements_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skills, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SkillRequirement)
	fc.Result = res
	return ec.marshalNSkillRequirement2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRequirements_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SkillRequirement_id(ctx, field)
			case "skill":
				return ec.fieldContext_SkillRequirement_skill(ctx, field)
			case "proficiency":
				return ec.fieldContext_SkillRequirement_proficiency(ctx, field)
			case "required":
				return ec.fieldContext_SkillRequirement_required(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SkillRequirement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRequirements_training(ctx context.Context, field graphql.CollectedField, obj *model.EventRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRequirements_training(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Training, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TrainingRequirement)
	fc.Result = res
	return ec.marshalNTrainingRequirement2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRequirements_training(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TrainingRequirement_id(ctx, field)
			case "name":
				return ec.fieldContext_TrainingRequirement_name(ctx, field)
			case "description":
				return ec.fieldContext_TrainingRequirement_description(ctx, field)
			case "required":
				return ec.fieldContext_TrainingRequirement_required(ctx, field)
			case "providedByOrganizer":
				return ec.fieldContext_TrainingRequirement_providedByOrganizer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TrainingRequirement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRequirements_interests(ctx context.Context, field graphql.CollectedField, obj *model.EventRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRequirements_interests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRequirements_interests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_id(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_updatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_fieldName(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_fieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_fieldName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_oldValue(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_oldValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_oldValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_newValue(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_newValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_newValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_updateType(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_updateType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateType)
	fc.Result = res
	return ec.marshalNUpdateType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_updateType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUpdate_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.EventUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUpdate_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUpdate_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Health_status(ctx context.Context, field graphql.CollectedField, obj *model.Health) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Health_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Health_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Health",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Health_time(ctx context.Context, field graphql.CollectedField, obj *model.Health) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Health_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Health_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Health",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interest_id(ctx context.Context, field graphql.CollectedField, obj *model.Interest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interest_name(ctx context.Context, field graphql.CollectedField, obj *model.Interest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interest_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interest_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interest_category(ctx context.Context, field graphql.CollectedField, obj *model.Interest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interest_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.InterestCategory)
	fc.Result = res
	return ec.marshalNInterestCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interest_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InterestCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_city(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.City, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_city(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_state(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_country(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_country(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_country(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_coordinates(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_coordinates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coordinates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Coordinates)
	fc.Result = res
	return ec.marshalOCoordinates2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinates(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_coordinates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lat":
				return ec.fieldContext_Coordinates_lat(ctx, field)
			case "lng":
				return ec.fieldContext_Coordinates_lng(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Coordinates", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_register(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_register(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Register(rctx, fc.Args["input"].(model.RegisterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthPayload)
	fc.Result = res
	return ec.marshalNAuthPayload2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAuthPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_register(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_AuthPayload_token(ctx, field)
			case "refreshToken":
				return ec.fieldContext_AuthPayload_refreshToken(ctx, field)
			case "user":
				return ec.fieldContext_AuthPayload_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_register_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Login(rctx, fc.Args["input"].(model.LoginInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthPayload)
	fc.Result = res
	return ec.marshalNAuthPayload2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAuthPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_AuthPayload_token(ctx, field)
			case "refreshToken":
				return ec.fieldContext_AuthPayload_refreshToken(ctx, field)
			case "user":
				return ec.fieldContext_AuthPayload_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshToken(rctx, fc.Args["input"].(model.RefreshTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthPayload)
	fc.Result = res
	return ec.marshalNAuthPayload2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAuthPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_AuthPayload_token(ctx, field)
			case "refreshToken":
				return ec.fieldContext_AuthPayload_refreshToken(ctx, field)
			case "user":
				return ec.fieldContext_AuthPayload_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Logout(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_googleAuthURL(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_googleAuthURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GoogleAuthURL(rctx, fc.Args["redirectURL"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_googleAuthURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_googleAuthURL_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_googleCallback(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_googleCallback(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GoogleCallback(rctx, fc.Args["code"].(string), fc.Args["state"].(string), fc.Args["redirectURL"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthPayload)
	fc.Result = res
	return ec.marshalNAuthPayload2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAuthPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_googleCallback(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_AuthPayload_token(ctx, field)
			case "refreshToken":
				return ec.fieldContext_AuthPayload_refreshToken(ctx, field)
			case "user":
				return ec.fieldContext_AuthPayload_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_googleCallback_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProfile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateProfile(rctx, fc.Args["input"].(model.UpdateProfileInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProfile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProfile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadProfilePicture(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadProfilePicture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UploadProfilePicture(rctx, fc.Args["file"].(graphql.Upload))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadProfilePicture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadProfilePicture_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateInterests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateInterests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateInterests(rctx, fc.Args["input"].(model.InterestInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateInterests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateInterests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addSkill(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addSkill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddSkill(rctx, fc.Args["input"].(model.SkillInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addSkill(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addSkill_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeSkill(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeSkill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveSkill(rctx, fc.Args["skillId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeSkill(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeSkill_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePrivacySettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePrivacySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePrivacySettings(rctx, fc.Args["input"].(model.PrivacySettingsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePrivacySettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePrivacySettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNotificationPreferences(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateNotificationPreferences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateNotificationPreferences(rctx, fc.Args["input"].(model.NotificationPreferencesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateNotificationPreferences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNotificationPreferences_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_changePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChangePassword(rctx, fc.Args["currentPassword"].(string), fc.Args["newPassword"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_changePassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deactivateAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deactivateAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeactivateAccount(rctx, fc.Args["confirmationCode"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deactivateAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deactivateAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exportUserData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_exportUserData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ExportUserData(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_exportUserData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(model.CreateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["id"].(string), fc.Args["input"].(model.UpdateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_publishEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_publishEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PublishEvent(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_publishEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_publishEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelEvent(rctx, fc.Args["id"].(string), fc.Args["reason"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addEventImage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addEventImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddEventImage(rctx, fc.Args["eventId"].(string), fc.Args["file"].(graphql.Upload), fc.Args["altText"].(*string), fc.Args["isPrimary"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventImage)
	fc.Result = res
	return ec.marshalNEventImage2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addEventImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventImage_id(ctx, field)
			case "url":
				return ec.fieldContext_EventImage_url(ctx, field)
			case "altText":
				return ec.fieldContext_EventImage_altText(ctx, field)
			case "isPrimary":
				return ec.fieldContext_EventImage_isPrimary(ctx, field)
			case "displayOrder":
				return ec.fieldContext_EventImage_displayOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventImage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addEventImage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEventImage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEventImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEventImage(rctx, fc.Args["id"].(string), fc.Args["altText"].(*string), fc.Args["isPrimary"].(*bool), fc.Args["displayOrder"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventImage)
	fc.Result = res
	return ec.marshalNEventImage2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEventImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventImage_id(ctx, field)
			case "url":
				return ec.fieldContext_EventImage_url(ctx, field)
			case "altText":
				return ec.fieldContext_EventImage_altText(ctx, field)
			case "isPrimary":
				return ec.fieldContext_EventImage_isPrimary(ctx, field)
			case "displayOrder":
				return ec.fieldContext_EventImage_displayOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventImage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEventImage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEventImage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEventImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEventImage(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEventImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEventImage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEventAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEventAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEventAnnouncement(rctx, fc.Args["eventId"].(string), fc.Args["title"].(string), fc.Args["content"].(string), fc.Args["isUrgent"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventAnnouncement)
	fc.Result = res
	return ec.marshalNEventAnnouncement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEventAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventAnnouncement_id(ctx, field)
			case "title":
				return ec.fieldContext_EventAnnouncement_title(ctx, field)
			case "content":
				return ec.fieldContext_EventAnnouncement_content(ctx, field)
			case "isUrgent":
				return ec.fieldContext_EventAnnouncement_isUrgent(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventAnnouncement_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventAnnouncement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEventAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEventAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEventAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEventAnnouncement(rctx, fc.Args["id"].(string), fc.Args["title"].(*string), fc.Args["content"].(*string), fc.Args["isUrgent"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventAnnouncement)
	fc.Result = res
	return ec.marshalNEventAnnouncement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEventAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventAnnouncement_id(ctx, field)
			case "title":
				return ec.fieldContext_EventAnnouncement_title(ctx, field)
			case "content":
				return ec.fieldContext_EventAnnouncement_content(ctx, field)
			case "isUrgent":
				return ec.fieldContext_EventAnnouncement_isUrgent(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventAnnouncement_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventAnnouncement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEventAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEventAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEventAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEventAnnouncement(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEventAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEventAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerForEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerForEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RegisterForEvent(rctx, fc.Args["input"].(model.RegisterForEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerForEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerForEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkRegister(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_bulkRegister(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().BulkRegister(rctx, fc.Args["input"].(model.BulkRegistrationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_bulkRegister(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkRegister_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelRegistration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelRegistration(rctx, fc.Args["registrationId"].(string), fc.Args["reason"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelRegistration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelRegistration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveRegistration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ApproveRegistration(rctx, fc.Args["input"].(model.ApprovalDecisionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveRegistration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveRegistration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_checkInVolunteer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_checkInVolunteer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CheckInVolunteer(rctx, fc.Args["input"].(model.AttendanceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AttendanceRecord)
	fc.Result = res
	return ec.marshalNAttendanceRecord2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_checkInVolunteer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "registration":
				return ec.fieldContext_AttendanceRecord_registration(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_AttendanceRecord_checkedInAt(ctx, field)
			case "checkedInBy":
				return ec.fieldContext_AttendanceRecord_checkedInBy(ctx, field)
			case "notes":
				return ec.fieldContext_AttendanceRecord_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AttendanceRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_checkInVolunteer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_markAttendance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_markAttendance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MarkAttendance(rctx, fc.Args["input"].(model.AttendanceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AttendanceRecord)
	fc.Result = res
	return ec.marshalNAttendanceRecord2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_markAttendance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "registration":
				return ec.fieldContext_AttendanceRecord_registration(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_AttendanceRecord_checkedInAt(ctx, field)
			case "checkedInBy":
				return ec.fieldContext_AttendanceRecord_checkedInBy(ctx, field)
			case "notes":
				return ec.fieldContext_AttendanceRecord_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AttendanceRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_markAttendance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_promoteFromWaitlist(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_promoteFromWaitlist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PromoteFromWaitlist(rctx, fc.Args["registrationId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_promoteFromWaitlist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_promoteFromWaitlist_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_transferRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_transferRegistration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TransferRegistration(rctx, fc.Args["registrationId"].(string), fc.Args["newEventId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_transferRegistration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_transferRegistration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRegistration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRegistration(rctx, fc.Args["registrationId"].(string), fc.Args["personalMessage"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRegistration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRegistration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NotificationPreferences_emailNotifications(ctx context.Context, field graphql.CollectedField, obj *model.NotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationPreferences_emailNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailNotifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationPreferences_emailNotifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationPreferences_pushNotifications(ctx context.Context, field graphql.CollectedField, obj *model.NotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationPreferences_pushNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushNotifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationPreferences_pushNotifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationPreferences_smsNotifications(ctx context.Context, field graphql.CollectedField, obj *model.NotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationPreferences_smsNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SmsNotifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationPreferences_smsNotifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationPreferences_eventReminders(ctx context.Context, field graphql.CollectedField, obj *model.NotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationPreferences_eventReminders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventReminders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationPreferences_eventReminders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationPreferences_newOpportunities(ctx context.Context, field graphql.CollectedField, obj *model.NotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationPreferences_newOpportunities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewOpportunities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationPreferences_newOpportunities(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationPreferences_newsletterSubscription(ctx context.Context, field graphql.CollectedField, obj *model.NotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationPreferences_newsletterSubscription(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewsletterSubscription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationPreferences_newsletterSubscription(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivacySettings_profileVisibility(ctx context.Context, field graphql.CollectedField, obj *model.PrivacySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivacySettings_profileVisibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileVisibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProfileVisibility)
	fc.Result = res
	return ec.marshalNProfileVisibility2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐProfileVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivacySettings_profileVisibility(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivacySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProfileVisibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivacySettings_showEmail(ctx context.Context, field graphql.CollectedField, obj *model.PrivacySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivacySettings_showEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivacySettings_showEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivacySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivacySettings_showLocation(ctx context.Context, field graphql.CollectedField, obj *model.PrivacySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivacySettings_showLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowLocation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivacySettings_showLocation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivacySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivacySettings_allowMessaging(ctx context.Context, field graphql.CollectedField, obj *model.PrivacySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivacySettings_allowMessaging(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowMessaging, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivacySettings_allowMessaging(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivacySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_id(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_name(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_bio(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_bio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_location(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalOLocation2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_location(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "city":
				return ec.fieldContext_Location_city(ctx, field)
			case "state":
				return ec.fieldContext_Location_state(ctx, field)
			case "country":
				return ec.fieldContext_Location_country(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_profilePicture(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_profilePicture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfilePicture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_profilePicture(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_interests(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_interests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PublicProfile().Interests(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Interest)
	fc.Result = res
	return ec.marshalNInterest2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_interests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interest_id(ctx, field)
			case "name":
				return ec.fieldContext_Interest_name(ctx, field)
			case "category":
				return ec.fieldContext_Interest_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_skills(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PublicProfile().Skills(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Skill)
	fc.Result = res
	return ec.marshalNSkill2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "proficiency":
				return ec.fieldContext_Skill_proficiency(ctx, field)
			case "verified":
				return ec.fieldContext_Skill_verified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicProfile_volunteerStats(ctx context.Context, field graphql.CollectedField, obj *model.PublicProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicProfile_volunteerStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PublicProfile().VolunteerStats(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VolunteerStats)
	fc.Result = res
	return ec.marshalNVolunteerStats2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐVolunteerStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicProfile_volunteerStats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicProfile",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hours":
				return ec.fieldContext_VolunteerStats_hours(ctx, field)
			case "eventsParticipated":
				return ec.fieldContext_VolunteerStats_eventsParticipated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VolunteerStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Health(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Health)
	fc.Result = res
	return ec.marshalNHealth2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐHealth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_health(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Health_status(ctx, field)
			case "time":
				return ec.fieldContext_Health_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Health", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PublicProfile)
	fc.Result = res
	return ec.marshalOPublicProfile2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PublicProfile_id(ctx, field)
			case "name":
				return ec.fieldContext_PublicProfile_name(ctx, field)
			case "bio":
				return ec.fieldContext_PublicProfile_bio(ctx, field)
			case "location":
				return ec.fieldContext_PublicProfile_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_PublicProfile_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_PublicProfile_interests(ctx, field)
			case "skills":
				return ec.fieldContext_PublicProfile_skills(ctx, field)
			case "volunteerStats":
				return ec.fieldContext_PublicProfile_volunteerStats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicProfile", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchUsers(rctx, fc.Args["filter"].(model.UserSearchFilter), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PublicProfile)
	fc.Result = res
	return ec.marshalNPublicProfile2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PublicProfile_id(ctx, field)
			case "name":
				return ec.fieldContext_PublicProfile_name(ctx, field)
			case "bio":
				return ec.fieldContext_PublicProfile_bio(ctx, field)
			case "location":
				return ec.fieldContext_PublicProfile_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_PublicProfile_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_PublicProfile_interests(ctx, field)
			case "skills":
				return ec.fieldContext_PublicProfile_skills(ctx, field)
			case "volunteerStats":
				return ec.fieldContext_PublicProfile_volunteerStats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicProfile", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_interests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_interests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Interests(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Interest)
	fc.Result = res
	return ec.marshalNInterest2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_interests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interest_id(ctx, field)
			case "name":
				return ec.fieldContext_Interest_name(ctx, field)
			case "category":
				return ec.fieldContext_Interest_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userActivity(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userActivity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserActivity(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ActivityLog)
	fc.Result = res
	return ec.marshalNActivityLog2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐActivityLogᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userActivity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ActivityLog_id(ctx, field)
			case "action":
				return ec.fieldContext_ActivityLog_action(ctx, field)
			case "ipAddress":
				return ec.fieldContext_ActivityLog_ipAddress(ctx, field)
			case "userAgent":
				return ec.fieldContext_ActivityLog_userAgent(ctx, field)
			case "createdAt":
				return ec.fieldContext_ActivityLog_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActivityLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_event(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Event(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalOEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_event_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_eventBySlug(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_eventBySlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EventBySlug(rctx, fc.Args["slug"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalOEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_eventBySlug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_eventBySlug_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx, fc.Args["filter"].(*model.EventSearchFilter), fc.Args["sort"].(*model.EventSortInput), fc.Args["first"].(*int), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EventConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchEvents(rctx, fc.Args["query"].(string), fc.Args["filter"].(*model.EventSearchFilter), fc.Args["sort"].(*model.EventSortInput), fc.Args["first"].(*int), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EventConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyEvents(rctx, fc.Args["status"].([]model.EventStatus), fc.Args["first"].(*int), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EventConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_myEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nearbyEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nearbyEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NearbyEvents(rctx, fc.Args["coordinates"].(model.CoordinatesInput), fc.Args["radius"].(float64), fc.Args["filter"].(*model.EventSearchFilter), fc.Args["first"].(*int), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventConnection)
	fc.Result = res
	return ec.marshalNEventConnection2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nearbyEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EventConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nearbyEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_eventUpdates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_eventUpdates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EventUpdates(rctx, fc.Args["eventId"].(string), fc.Args["first"].(*int), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EventUpdate)
	fc.Result = res
	return ec.marshalNEventUpdate2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventUpdateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_eventUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventUpdate_id(ctx, field)
			case "updatedBy":
				return ec.fieldContext_EventUpdate_updatedBy(ctx, field)
			case "fieldName":
				return ec.fieldContext_EventUpdate_fieldName(ctx, field)
			case "oldValue":
				return ec.fieldContext_EventUpdate_oldValue(ctx, field)
			case "newValue":
				return ec.fieldContext_EventUpdate_newValue(ctx, field)
			case "updateType":
				return ec.fieldContext_EventUpdate_updateType(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventUpdate_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUpdate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_eventUpdates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myRegistrations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyRegistrations(rctx, fc.Args["filter"].(*model.RegistrationFilterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myRegistrations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_myRegistrations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_registration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_registration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Registration(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalORegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_registration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_registration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_eventRegistrations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_eventRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EventRegistrations(rctx, fc.Args["eventId"].(string), fc.Args["filter"].(*model.RegistrationFilterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_eventRegistrations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_eventRegistrations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_waitlistEntries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_waitlistEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WaitlistEntries(rctx, fc.Args["eventId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WaitlistEntry)
	fc.Result = res
	return ec.marshalNWaitlistEntry2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐWaitlistEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_waitlistEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaitlistEntry_id(ctx, field)
			case "registration":
				return ec.fieldContext_WaitlistEntry_registration(ctx, field)
			case "position":
				return ec.fieldContext_WaitlistEntry_position(ctx, field)
			case "estimatedPromotionTime":
				return ec.fieldContext_WaitlistEntry_estimatedPromotionTime(ctx, field)
			case "promotionOfferedAt":
				return ec.fieldContext_WaitlistEntry_promotionOfferedAt(ctx, field)
			case "promotionExpiresAt":
				return ec.fieldContext_WaitlistEntry_promotionExpiresAt(ctx, field)
			case "autoPromote":
				return ec.fieldContext_WaitlistEntry_autoPromote(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaitlistEntry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_waitlistEntries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_registrationConflicts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_registrationConflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RegistrationConflicts(rctx, fc.Args["eventId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RegistrationConflict)
	fc.Result = res
	return ec.marshalNRegistrationConflict2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationConflictᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_registrationConflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conflictingEvent":
				return ec.fieldContext_RegistrationConflict_conflictingEvent(ctx, field)
			case "conflictType":
				return ec.fieldContext_RegistrationConflict_conflictType(ctx, field)
			case "severity":
				return ec.fieldContext_RegistrationConflict_severity(ctx, field)
			case "suggestions":
				return ec.fieldContext_RegistrationConflict_suggestions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegistrationConflict", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_registrationConflicts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_attendanceRecords(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_attendanceRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AttendanceRecords(rctx, fc.Args["eventId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AttendanceRecord)
	fc.Result = res
	return ec.marshalNAttendanceRecord2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecordᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_attendanceRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "registration":
				return ec.fieldContext_AttendanceRecord_registration(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_AttendanceRecord_checkedInAt(ctx, field)
			case "checkedInBy":
				return ec.fieldContext_AttendanceRecord_checkedInBy(ctx, field)
			case "notes":
				return ec.fieldContext_AttendanceRecord_notes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AttendanceRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_attendanceRecords_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_registrationStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_registrationStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RegistrationStats(rctx, fc.Args["eventId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegistrationStats)
	fc.Result = res
	return ec.marshalNRegistrationStats2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_registrationStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalRegistrations":
				return ec.fieldContext_RegistrationStats_totalRegistrations(ctx, field)
			case "confirmedRegistrations":
				return ec.fieldContext_RegistrationStats_confirmedRegistrations(ctx, field)
			case "waitlistCount":
				return ec.fieldContext_RegistrationStats_waitlistCount(ctx, field)
			case "attendanceRate":
				return ec.fieldContext_RegistrationStats_attendanceRate(ctx, field)
			case "noShowRate":
				return ec.fieldContext_RegistrationStats_noShowRate(ctx, field)
			case "cancellationRate":
				return ec.fieldContext_RegistrationStats_cancellationRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegistrationStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_registrationStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecurrenceRule_frequency(ctx context.Context, field graphql.CollectedField, obj *model.RecurrenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecurrenceRule_frequency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Frequency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RecurrenceFrequency)
	fc.Result = res
	return ec.marshalNRecurrenceFrequency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceFrequency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecurrenceRule_frequency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecurrenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RecurrenceFrequency does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecurrenceRule_interval(ctx context.Context, field graphql.CollectedField, obj *model.RecurrenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecurrenceRule_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecurrenceRule_interval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecurrenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecurrenceRule_daysOfWeek(ctx context.Context, field graphql.CollectedField, obj *model.RecurrenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecurrenceRule_daysOfWeek(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DaysOfWeek, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.DayOfWeek)
	fc.Result = res
	return ec.marshalODayOfWeek2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeekᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecurrenceRule_daysOfWeek(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecurrenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DayOfWeek does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecurrenceRule_dayOfMonth(ctx context.Context, field graphql.CollectedField, obj *model.RecurrenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecurrenceRule_dayOfMonth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayOfMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecurrenceRule_dayOfMonth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecurrenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecurrenceRule_endDate(ctx context.Context, field graphql.CollectedField, obj *model.RecurrenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecurrenceRule_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecurrenceRule_endDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecurrenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecurrenceRule_occurrenceCount(ctx context.Context, field graphql.CollectedField, obj *model.RecurrenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecurrenceRule_occurrenceCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OccurrenceCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecurrenceRule_occurrenceCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecurrenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_id(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_user(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Registration().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			case "googleId":
				return ec.fieldContext_User_googleId(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "bio":
				return ec.fieldContext_User_bio(ctx, field)
			case "location":
				return ec.fieldContext_User_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_User_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_User_interests(ctx, field)
			case "skills":
				return ec.fieldContext_User_skills(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "isVerified":
				return ec.fieldContext_User_isVerified(ctx, field)
			case "joinedAt":
				return ec.fieldContext_User_joinedAt(ctx, field)
			case "lastActiveAt":
				return ec.fieldContext_User_lastActiveAt(ctx, field)
			case "publicProfile":
				return ec.fieldContext_User_publicProfile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_event(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Registration().Event(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_event(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_status(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RegistrationStatus)
	fc.Result = res
	return ec.marshalNRegistrationStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RegistrationStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_personalMessage(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_personalMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersonalMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_personalMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_skills(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Registration().Skills(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.UserSkill)
	fc.Result = res
	return ec.marshalNUserSkill2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUserSkillᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSkill_id(ctx, field)
			case "name":
				return ec.fieldContext_UserSkill_name(ctx, field)
			case "proficiency":
				return ec.fieldContext_UserSkill_proficiency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSkill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_interests(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_interests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Registration().Interests(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Interest)
	fc.Result = res
	return ec.marshalNInterest2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_interests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interest_id(ctx, field)
			case "name":
				return ec.fieldContext_Interest_name(ctx, field)
			case "category":
				return ec.fieldContext_Interest_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_appliedAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_appliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_appliedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_confirmedAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_confirmedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfirmedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_confirmedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_cancelledAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_cancelledAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelledAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_cancelledAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_checkedInAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_checkedInAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedInAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_checkedInAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_waitlistPosition(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_waitlistPosition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitlistPosition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_waitlistPosition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_approvalNotes(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_approvalNotes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovalNotes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_approvalNotes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_cancellationReason(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_cancellationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancellationReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_cancellationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_attendanceStatus(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_attendanceStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AttendanceStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AttendanceStatus)
	fc.Result = res
	return ec.marshalNAttendanceStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_attendanceStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AttendanceStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_canCancel(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_canCancel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanCancel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_canCancel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_canCheckIn(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_canCheckIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanCheckIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_canCheckIn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Registration_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Registration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Registration_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Registration_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Registration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationConflict_conflictingEvent(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationConflict_conflictingEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConflictingEvent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationConflict_conflictingEvent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationConflict_conflictType(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationConflict_conflictType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConflictType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConflictType)
	fc.Result = res
	return ec.marshalNConflictType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐConflictType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationConflict_conflictType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConflictType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationConflict_severity(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationConflict_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConflictSeverity)
	fc.Result = res
	return ec.marshalNConflictSeverity2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐConflictSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationConflict_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConflictSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationConflict_suggestions(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationConflict_suggestions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suggestions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationConflict_suggestions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "shortDescription":
				return ec.fieldContext_Event_shortDescription(ctx, field)
			case "organizer":
				return ec.fieldContext_Event_organizer(ctx, field)
			case "organizerId":
				return ec.fieldContext_Event_organizerId(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "startTime":
				return ec.fieldContext_Event_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Event_endTime(ctx, field)
			case "location":
				return ec.fieldContext_Event_location(ctx, field)
			case "capacity":
				return ec.fieldContext_Event_capacity(ctx, field)
			case "requirements":
				return ec.fieldContext_Event_requirements(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "timeCommitment":
				return ec.fieldContext_Event_timeCommitment(ctx, field)
			case "tags":
				return ec.fieldContext_Event_tags(ctx, field)
			case "slug":
				return ec.fieldContext_Event_slug(ctx, field)
			case "shareURL":
				return ec.fieldContext_Event_shareURL(ctx, field)
			case "recurrenceRule":
				return ec.fieldContext_Event_recurrenceRule(ctx, field)
			case "registrationSettings":
				return ec.fieldContext_Event_registrationSettings(ctx, field)
			case "images":
				return ec.fieldContext_Event_images(ctx, field)
			case "announcements":
				return ec.fieldContext_Event_announcements(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "currentRegistrations":
				return ec.fieldContext_Event_currentRegistrations(ctx, field)
			case "availableSpots":
				return ec.fieldContext_Event_availableSpots(ctx, field)
			case "isAtCapacity":
				return ec.fieldContext_Event_isAtCapacity(ctx, field)
			case "canRegister":
				return ec.fieldContext_Event_canRegister(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationSettings_opensAt(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationSettings_opensAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpensAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationSettings_opensAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationSettings_closesAt(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationSettings_closesAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosesAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationSettings_closesAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationSettings_requiresApproval(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationSettings_requiresApproval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiresApproval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationSettings_requiresApproval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationSettings_allowWaitlist(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationSettings_allowWaitlist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowWaitlist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationSettings_allowWaitlist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationSettings_confirmationRequired(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationSettings_confirmationRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfirmationRequired, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationSettings_confirmationRequired(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationSettings_cancellationDeadline(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationSettings_cancellationDeadline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancellationDeadline, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationSettings_cancellationDeadline(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationStats_totalRegistrations(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationStats_totalRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRegistrations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationStats_totalRegistrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationStats_confirmedRegistrations(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationStats_confirmedRegistrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfirmedRegistrations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationStats_confirmedRegistrations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationStats_waitlistCount(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationStats_waitlistCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitlistCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationStats_waitlistCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationStats_attendanceRate(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationStats_attendanceRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AttendanceRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationStats_attendanceRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationStats_noShowRate(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationStats_noShowRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoShowRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationStats_noShowRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationStats_cancellationRate(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationStats_cancellationRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancellationRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationStats_cancellationRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_id(ctx context.Context, field graphql.CollectedField, obj *model.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_name(ctx context.Context, field graphql.CollectedField, obj *model.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_proficiency(ctx context.Context, field graphql.CollectedField, obj *model.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_proficiency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SkillProficiency)
	fc.Result = res
	return ec.marshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_proficiency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SkillProficiency does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_verified(ctx context.Context, field graphql.CollectedField, obj *model.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_verified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_verified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SkillRequirement_id(ctx context.Context, field graphql.CollectedField, obj *model.SkillRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SkillRequirement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SkillRequirement_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SkillRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SkillRequirement_skill(ctx context.Context, field graphql.CollectedField, obj *model.SkillRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SkillRequirement_skill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skill, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SkillRequirement_skill(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SkillRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SkillRequirement_proficiency(ctx context.Context, field graphql.CollectedField, obj *model.SkillRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SkillRequirement_proficiency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SkillProficiency)
	fc.Result = res
	return ec.marshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SkillRequirement_proficiency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SkillRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SkillProficiency does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SkillRequirement_required(ctx context.Context, field graphql.CollectedField, obj *model.SkillRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SkillRequirement_required(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Required, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SkillRequirement_required(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SkillRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingRequirement_id(ctx context.Context, field graphql.CollectedField, obj *model.TrainingRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingRequirement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingRequirement_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingRequirement_name(ctx context.Context, field graphql.CollectedField, obj *model.TrainingRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingRequirement_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingRequirement_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingRequirement_description(ctx context.Context, field graphql.CollectedField, obj *model.TrainingRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingRequirement_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingRequirement_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingRequirement_required(ctx context.Context, field graphql.CollectedField, obj *model.TrainingRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingRequirement_required(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Required, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingRequirement_required(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TrainingRequirement_providedByOrganizer(ctx context.Context, field graphql.CollectedField, obj *model.TrainingRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TrainingRequirement_providedByOrganizer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvidedByOrganizer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TrainingRequirement_providedByOrganizer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TrainingRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_emailVerified(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_emailVerified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_emailVerified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_googleId(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_googleId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_googleId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastLogin(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastLogin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastLogin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastLogin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_bio(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_bio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_location(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalOLocation2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_location(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "city":
				return ec.fieldContext_Location_city(ctx, field)
			case "state":
				return ec.fieldContext_Location_state(ctx, field)
			case "country":
				return ec.fieldContext_Location_country(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_profilePicture(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_profilePicture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfilePicture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_profilePicture(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_interests(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_interests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Interests(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Interest)
	fc.Result = res
	return ec.marshalNInterest2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_interests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interest_id(ctx, field)
			case "name":
				return ec.fieldContext_Interest_name(ctx, field)
			case "category":
				return ec.fieldContext_Interest_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_skills(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Skills(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Skill)
	fc.Result = res
	return ec.marshalNSkill2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "proficiency":
				return ec.fieldContext_Skill_proficiency(ctx, field)
			case "verified":
				return ec.fieldContext_Skill_verified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_isVerified(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_isVerified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_isVerified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_joinedAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_joinedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JoinedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_joinedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastActiveAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastActiveAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastActiveAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastActiveAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_publicProfile(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_publicProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().PublicProfile(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PublicProfile)
	fc.Result = res
	return ec.marshalNPublicProfile2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_publicProfile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PublicProfile_id(ctx, field)
			case "name":
				return ec.fieldContext_PublicProfile_name(ctx, field)
			case "bio":
				return ec.fieldContext_PublicProfile_bio(ctx, field)
			case "location":
				return ec.fieldContext_PublicProfile_location(ctx, field)
			case "profilePicture":
				return ec.fieldContext_PublicProfile_profilePicture(ctx, field)
			case "interests":
				return ec.fieldContext_PublicProfile_interests(ctx, field)
			case "skills":
				return ec.fieldContext_PublicProfile_skills(ctx, field)
			case "volunteerStats":
				return ec.fieldContext_PublicProfile_volunteerStats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicProfile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSkill_id(ctx context.Context, field graphql.CollectedField, obj *model.UserSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSkill_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSkill_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSkill_name(ctx context.Context, field graphql.CollectedField, obj *model.UserSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSkill_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSkill_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSkill_proficiency(ctx context.Context, field graphql.CollectedField, obj *model.UserSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSkill_proficiency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SkillProficiency)
	fc.Result = res
	return ec.marshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSkill_proficiency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SkillProficiency does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VolunteerStats_hours(ctx context.Context, field graphql.CollectedField, obj *model.VolunteerStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VolunteerStats_hours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VolunteerStats_hours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VolunteerStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VolunteerStats_eventsParticipated(ctx context.Context, field graphql.CollectedField, obj *model.VolunteerStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VolunteerStats_eventsParticipated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventsParticipated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VolunteerStats_eventsParticipated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VolunteerStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_registration(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_registration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Registration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Registration)
	fc.Result = res
	return ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_registration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Registration_id(ctx, field)
			case "user":
				return ec.fieldContext_Registration_user(ctx, field)
			case "event":
				return ec.fieldContext_Registration_event(ctx, field)
			case "status":
				return ec.fieldContext_Registration_status(ctx, field)
			case "personalMessage":
				return ec.fieldContext_Registration_personalMessage(ctx, field)
			case "skills":
				return ec.fieldContext_Registration_skills(ctx, field)
			case "interests":
				return ec.fieldContext_Registration_interests(ctx, field)
			case "appliedAt":
				return ec.fieldContext_Registration_appliedAt(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_Registration_confirmedAt(ctx, field)
			case "cancelledAt":
				return ec.fieldContext_Registration_cancelledAt(ctx, field)
			case "checkedInAt":
				return ec.fieldContext_Registration_checkedInAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Registration_completedAt(ctx, field)
			case "waitlistPosition":
				return ec.fieldContext_Registration_waitlistPosition(ctx, field)
			case "approvalNotes":
				return ec.fieldContext_Registration_approvalNotes(ctx, field)
			case "cancellationReason":
				return ec.fieldContext_Registration_cancellationReason(ctx, field)
			case "attendanceStatus":
				return ec.fieldContext_Registration_attendanceStatus(ctx, field)
			case "canCancel":
				return ec.fieldContext_Registration_canCancel(ctx, field)
			case "canCheckIn":
				return ec.fieldContext_Registration_canCheckIn(ctx, field)
			case "createdAt":
				return ec.fieldContext_Registration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Registration_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Registration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_position(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_estimatedPromotionTime(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_estimatedPromotionTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedPromotionTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_estimatedPromotionTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_promotionOfferedAt(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_promotionOfferedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromotionOfferedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_promotionOfferedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_promotionExpiresAt(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_promotionExpiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromotionExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_promotionExpiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitlistEntry_autoPromote(ctx context.Context, field graphql.CollectedField, obj *model.WaitlistEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitlistEntry_autoPromote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoPromote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitlistEntry_autoPromote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitlistEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputApprovalDecisionInput(ctx context.Context, obj any) (model.ApprovalDecisionInput, error) {
	var it model.ApprovalDecisionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"registrationId", "approved", "notes", "conditions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "registrationId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registrationId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegistrationID = data
		case "approved":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("approved"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Approved = data
		case "notes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notes"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notes = data
		case "conditions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conditions"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Conditions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAttendanceInput(ctx context.Context, obj any) (model.AttendanceInput, error) {
	var it model.AttendanceInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"registrationId", "status", "notes", "checkedInAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "registrationId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registrationId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegistrationID = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNAttendanceStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "notes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notes"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notes = data
		case "checkedInAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkedInAt"))
			data, err := ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CheckedInAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkRegistrationInput(ctx context.Context, obj any) (model.BulkRegistrationInput, error) {
	var it model.BulkRegistrationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eventIds", "personalMessage", "skipConflicts"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eventIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIds"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventIds = data
		case "personalMessage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalMessage"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersonalMessage = data
		case "skipConflicts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipConflicts"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipConflicts = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoordinatesInput(ctx context.Context, obj any) (model.CoordinatesInput, error) {
	var it model.CoordinatesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lat", "lng"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lat = data
		case "lng":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lng"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lng = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventInput(ctx context.Context, obj any) (model.CreateEventInput, error) {
	var it model.CreateEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "shortDescription", "startTime", "endTime", "location", "capacity", "requirements", "tags", "category", "timeCommitment", "recurrenceRule", "registrationSettings"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "shortDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shortDescription"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "startTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startTime"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartTime = data
		case "endTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endTime"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndTime = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalNEventLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventLocationInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "capacity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacity"))
			data, err := ec.unmarshalNEventCapacityInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCapacityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Capacity = data
		case "requirements":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requirements"))
			data, err := ec.unmarshalOEventRequirementsInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventRequirementsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requirements = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalNEventCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "timeCommitment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeCommitment"))
			data, err := ec.unmarshalNTimeCommitmentType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeCommitment = data
		case "recurrenceRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recurrenceRule"))
			data, err := ec.unmarshalORecurrenceRuleInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceRuleInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.RecurrenceRule = data
		case "registrationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registrationSettings"))
			data, err := ec.unmarshalNRegistrationSettingsInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationSettingsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegistrationSettings = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateRangeInput(ctx context.Context, obj any) (model.DateRangeInput, error) {
	var it model.DateRangeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEmergencyContactInput(ctx context.Context, obj any) (model.EmergencyContactInput, error) {
	var it model.EmergencyContactInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "phone"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventCapacityInput(ctx context.Context, obj any) (model.EventCapacityInput, error) {
	var it model.EventCapacityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"minimum", "maximum", "waitlistEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "minimum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimum"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Minimum = data
		case "maximum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maximum"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Maximum = data
		case "waitlistEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("waitlistEnabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WaitlistEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventLocationInput(ctx context.Context, obj any) (model.EventLocationInput, error) {
	var it model.EventLocationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "address", "city", "state", "country", "zipCode", "coordinates", "instructions", "isRemote"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Address = data
		case "city":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.City = data
		case "state":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "zipCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zipCode"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ZipCode = data
		case "coordinates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			data, err := ec.unmarshalOCoordinatesInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinatesInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Coordinates = data
		case "instructions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instructions"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Instructions = data
		case "isRemote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRemote"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRemote = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRequirementsInput(ctx context.Context, obj any) (model.EventRequirementsInput, error) {
	var it model.EventRequirementsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"minimumAge", "backgroundCheck", "physicalRequirements", "skills", "training", "interests"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "minimumAge":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumAge"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumAge = data
		case "backgroundCheck":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundCheck"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundCheck = data
		case "physicalRequirements":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("physicalRequirements"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PhysicalRequirements = data
		case "skills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skills"))
			data, err := ec.unmarshalOSkillRequirementInput2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirementInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Skills = data
		case "training":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("training"))
			data, err := ec.unmarshalOTrainingRequirementInput2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirementInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Training = data
		case "interests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interests"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Interests = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventSearchFilter(ctx context.Context, obj any) (model.EventSearchFilter, error) {
	var it model.EventSearchFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"query", "status", "category", "timeCommitment", "organizerId", "tags", "startDate", "endDate", "location", "skills", "interests", "requiresBackgroundCheck", "minimumAge"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOEventStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatusᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOEventCategory2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategoryᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "timeCommitment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeCommitment"))
			data, err := ec.unmarshalOTimeCommitmentType2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeCommitment = data
		case "organizerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizerId"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizerID = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "startDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOLocationSearchInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocationSearchInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "skills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skills"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Skills = data
		case "interests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interests"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Interests = data
		case "requiresBackgroundCheck":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requiresBackgroundCheck"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequiresBackgroundCheck = data
		case "minimumAge":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumAge"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumAge = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventSortInput(ctx context.Context, obj any) (model.EventSortInput, error) {
	var it model.EventSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNEventSortField2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSortField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirection2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterestInput(ctx context.Context, obj any) (model.InterestInput, error) {
	var it model.InterestInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"interestIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "interestIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interestIds"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.InterestIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLocationInput(ctx context.Context, obj any) (model.LocationInput, error) {
	var it model.LocationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"city", "state", "country", "lat", "lng"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "city":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.City = data
		case "state":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lat = data
		case "lng":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lng"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lng = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLocationSearchInput(ctx context.Context, obj any) (model.LocationSearchInput, error) {
	var it model.LocationSearchInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"city", "state", "country", "radius", "coordinates"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "city":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.City = data
		case "state":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "radius":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Radius = data
		case "coordinates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			data, err := ec.unmarshalOCoordinatesInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinatesInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Coordinates = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoginInput(ctx context.Context, obj any) (model.LoginInput, error) {
	var it model.LoginInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationPreferencesInput(ctx context.Context, obj any) (model.NotificationPreferencesInput, error) {
	var it model.NotificationPreferencesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"emailNotifications", "pushNotifications", "smsNotifications", "eventReminders", "newOpportunities", "newsletterSubscription"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "emailNotifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotifications"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotifications = data
		case "pushNotifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushNotifications"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PushNotifications = data
		case "smsNotifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smsNotifications"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SmsNotifications = data
		case "eventReminders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventReminders"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventReminders = data
		case "newOpportunities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newOpportunities"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewOpportunities = data
		case "newsletterSubscription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newsletterSubscription"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewsletterSubscription = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrivacySettingsInput(ctx context.Context, obj any) (model.PrivacySettingsInput, error) {
	var it model.PrivacySettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"profileVisibility", "showEmail", "showLocation", "allowMessaging"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "profileVisibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("profileVisibility"))
			data, err := ec.unmarshalOProfileVisibility2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐProfileVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProfileVisibility = data
		case "showEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showEmail"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowEmail = data
		case "showLocation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showLocation"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowLocation = data
		case "allowMessaging":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowMessaging"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowMessaging = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRecurrenceRuleInput(ctx context.Context, obj any) (model.RecurrenceRuleInput, error) {
	var it model.RecurrenceRuleInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"frequency", "interval", "daysOfWeek", "dayOfMonth", "endDate", "occurrenceCount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "frequency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frequency"))
			data, err := ec.unmarshalNRecurrenceFrequency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceFrequency(ctx, v)
			if err != nil {
				return it, err
			}
			it.Frequency = data
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Interval = data
		case "daysOfWeek":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysOfWeek"))
			data, err := ec.unmarshalODayOfWeek2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeekᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysOfWeek = data
		case "dayOfMonth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayOfMonth"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayOfMonth = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "occurrenceCount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("occurrenceCount"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OccurrenceCount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefreshTokenInput(ctx context.Context, obj any) (model.RefreshTokenInput, error) {
	var it model.RefreshTokenInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"refreshToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "refreshToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("refreshToken"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RefreshToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegisterForEventInput(ctx context.Context, obj any) (model.RegisterForEventInput, error) {
	var it model.RegisterForEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eventId", "personalMessage", "emergencyContact", "dietaryRestrictions", "accessibilityNeeds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eventId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventID = data
		case "personalMessage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalMessage"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersonalMessage = data
		case "emergencyContact":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emergencyContact"))
			data, err := ec.unmarshalOEmergencyContactInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEmergencyContactInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmergencyContact = data
		case "dietaryRestrictions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dietaryRestrictions"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DietaryRestrictions = data
		case "accessibilityNeeds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessibilityNeeds"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessibilityNeeds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegisterInput(ctx context.Context, obj any) (model.RegisterInput, error) {
	var it model.RegisterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "email", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationFilterInput(ctx context.Context, obj any) (model.RegistrationFilterInput, error) {
	var it model.RegistrationFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eventId", "userId", "status", "dateRange", "attendanceStatus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eventId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventId"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventID = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalORegistrationStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatusᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "dateRange":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateRange"))
			data, err := ec.unmarshalODateRangeInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDateRangeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateRange = data
		case "attendanceStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attendanceStatus"))
			data, err := ec.unmarshalOAttendanceStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatusᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AttendanceStatus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationSettingsInput(ctx context.Context, obj any) (model.RegistrationSettingsInput, error) {
	var it model.RegistrationSettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"opensAt", "closesAt", "requiresApproval", "allowWaitlist", "confirmationRequired", "cancellationDeadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "opensAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opensAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpensAt = data
		case "closesAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("closesAt"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClosesAt = data
		case "requiresApproval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requiresApproval"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequiresApproval = data
		case "allowWaitlist":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowWaitlist"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowWaitlist = data
		case "confirmationRequired":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirmationRequired"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfirmationRequired = data
		case "cancellationDeadline":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancellationDeadline"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CancellationDeadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSkillInput(ctx context.Context, obj any) (model.SkillInput, error) {
	var it model.SkillInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "proficiency"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "proficiency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiency"))
			data, err := ec.unmarshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx, v)
			if err != nil {
				return it, err
			}
			it.Proficiency = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSkillRequirementInput(ctx context.Context, obj any) (model.SkillRequirementInput, error) {
	var it model.SkillRequirementInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"skill", "proficiency", "required"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "skill":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skill"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Skill = data
		case "proficiency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiency"))
			data, err := ec.unmarshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx, v)
			if err != nil {
				return it, err
			}
			it.Proficiency = data
		case "required":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("required"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Required = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTrainingRequirementInput(ctx context.Context, obj any) (model.TrainingRequirementInput, error) {
	var it model.TrainingRequirementInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "required", "providedByOrganizer"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "required":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("required"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Required = data
		case "providedByOrganizer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providedByOrganizer"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProvidedByOrganizer = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj any) (model.UpdateEventInput, error) {
	var it model.UpdateEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "shortDescription", "location", "requirements", "tags", "category"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "shortDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shortDescription"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOEventLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventLocationInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "requirements":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requirements"))
			data, err := ec.unmarshalOEventRequirementsInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventRequirementsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requirements = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOEventCategory2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProfileInput(ctx context.Context, obj any) (model.UpdateProfileInput, error) {
	var it model.UpdateProfileInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "bio", "location"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocationInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSearchFilter(ctx context.Context, obj any) (model.UserSearchFilter, error) {
	var it model.UserSearchFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"skills", "interests", "location", "availability", "experience"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "skills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skills"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Skills = data
		case "interests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interests"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Interests = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocationInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "availability":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("availability"))
			data, err := ec.unmarshalOAvailabilityStatus2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAvailabilityStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Availability = data
		case "experience":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("experience"))
			data, err := ec.unmarshalOExperienceLevel2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐExperienceLevel(ctx, v)
			if err != nil {
				return it, err
			}
			it.Experience = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var activityLogImplementors = []string{"ActivityLog"}

func (ec *executionContext) _ActivityLog(ctx context.Context, sel ast.SelectionSet, obj *model.ActivityLog) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, activityLogImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActivityLog")
		case "id":
			out.Values[i] = ec._ActivityLog_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._ActivityLog_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddress":
			out.Values[i] = ec._ActivityLog_ipAddress(ctx, field, obj)
		case "userAgent":
			out.Values[i] = ec._ActivityLog_userAgent(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ActivityLog_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var attendanceRecordImplementors = []string{"AttendanceRecord"}

func (ec *executionContext) _AttendanceRecord(ctx context.Context, sel ast.SelectionSet, obj *model.AttendanceRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attendanceRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttendanceRecord")
		case "registration":
			out.Values[i] = ec._AttendanceRecord_registration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkedInAt":
			out.Values[i] = ec._AttendanceRecord_checkedInAt(ctx, field, obj)
		case "checkedInBy":
			out.Values[i] = ec._AttendanceRecord_checkedInBy(ctx, field, obj)
		case "notes":
			out.Values[i] = ec._AttendanceRecord_notes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authPayloadImplementors = []string{"AuthPayload"}

func (ec *executionContext) _AuthPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AuthPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthPayload")
		case "token":
			out.Values[i] = ec._AuthPayload_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshToken":
			out.Values[i] = ec._AuthPayload_refreshToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AuthPayload_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var coordinatesImplementors = []string{"Coordinates"}

func (ec *executionContext) _Coordinates(ctx context.Context, sel ast.SelectionSet, obj *model.Coordinates) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coordinatesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Coordinates")
		case "lat":
			out.Values[i] = ec._Coordinates_lat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lng":
			out.Values[i] = ec._Coordinates_lng(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *model.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Event_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Event_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shortDescription":
			out.Values[i] = ec._Event_shortDescription(ctx, field, obj)
		case "organizer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_organizer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "organizerId":
			out.Values[i] = ec._Event_organizerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Event_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Event_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "endTime":
			out.Values[i] = ec._Event_endTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "location":
			out.Values[i] = ec._Event_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "capacity":
			out.Values[i] = ec._Event_capacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "requirements":
			out.Values[i] = ec._Event_requirements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "category":
			out.Values[i] = ec._Event_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeCommitment":
			out.Values[i] = ec._Event_timeCommitment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Event_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slug":
			out.Values[i] = ec._Event_slug(ctx, field, obj)
		case "shareURL":
			out.Values[i] = ec._Event_shareURL(ctx, field, obj)
		case "recurrenceRule":
			out.Values[i] = ec._Event_recurrenceRule(ctx, field, obj)
		case "registrationSettings":
			out.Values[i] = ec._Event_registrationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "announcements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_announcements(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currentRegistrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_currentRegistrations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "availableSpots":
			out.Values[i] = ec._Event_availableSpots(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isAtCapacity":
			out.Values[i] = ec._Event_isAtCapacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canRegister":
			out.Values[i] = ec._Event_canRegister(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventAnnouncementImplementors = []string{"EventAnnouncement"}

func (ec *executionContext) _EventAnnouncement(ctx context.Context, sel ast.SelectionSet, obj *model.EventAnnouncement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventAnnouncementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventAnnouncement")
		case "id":
			out.Values[i] = ec._EventAnnouncement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._EventAnnouncement_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content":
			out.Values[i] = ec._EventAnnouncement_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isUrgent":
			out.Values[i] = ec._EventAnnouncement_isUrgent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventAnnouncement_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventCapacityImplementors = []string{"EventCapacity"}

func (ec *executionContext) _EventCapacity(ctx context.Context, sel ast.SelectionSet, obj *model.EventCapacity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventCapacityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventCapacity")
		case "minimum":
			out.Values[i] = ec._EventCapacity_minimum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maximum":
			out.Values[i] = ec._EventCapacity_maximum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "current":
			out.Values[i] = ec._EventCapacity_current(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "waitlistEnabled":
			out.Values[i] = ec._EventCapacity_waitlistEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventConnectionImplementors = []string{"EventConnection"}

func (ec *executionContext) _EventConnection(ctx context.Context, sel ast.SelectionSet, obj *model.EventConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventConnection")
		case "edges":
			out.Values[i] = ec._EventConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._EventConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._EventConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventEdgeImplementors = []string{"EventEdge"}

func (ec *executionContext) _EventEdge(ctx context.Context, sel ast.SelectionSet, obj *model.EventEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventEdge")
		case "node":
			out.Values[i] = ec._EventEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._EventEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImageImplementors = []string{"EventImage"}

func (ec *executionContext) _EventImage(ctx context.Context, sel ast.SelectionSet, obj *model.EventImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventImage")
		case "id":
			out.Values[i] = ec._EventImage_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._EventImage_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "altText":
			out.Values[i] = ec._EventImage_altText(ctx, field, obj)
		case "isPrimary":
			out.Values[i] = ec._EventImage_isPrimary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayOrder":
			out.Values[i] = ec._EventImage_displayOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventLocationImplementors = []string{"EventLocation"}

func (ec *executionContext) _EventLocation(ctx context.Context, sel ast.SelectionSet, obj *model.EventLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventLocation")
		case "name":
			out.Values[i] = ec._EventLocation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._EventLocation_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "city":
			out.Values[i] = ec._EventLocation_city(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._EventLocation_state(ctx, field, obj)
		case "country":
			out.Values[i] = ec._EventLocation_country(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zipCode":
			out.Values[i] = ec._EventLocation_zipCode(ctx, field, obj)
		case "coordinates":
			out.Values[i] = ec._EventLocation_coordinates(ctx, field, obj)
		case "instructions":
			out.Values[i] = ec._EventLocation_instructions(ctx, field, obj)
		case "isRemote":
			out.Values[i] = ec._EventLocation_isRemote(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventRequirementsImplementors = []string{"EventRequirements"}

func (ec *executionContext) _EventRequirements(ctx context.Context, sel ast.SelectionSet, obj *model.EventRequirements) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventRequirementsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventRequirements")
		case "minimumAge":
			out.Values[i] = ec._EventRequirements_minimumAge(ctx, field, obj)
		case "backgroundCheck":
			out.Values[i] = ec._EventRequirements_backgroundCheck(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "physicalRequirements":
			out.Values[i] = ec._EventRequirements_physicalRequirements(ctx, field, obj)
		case "skills":
			out.Values[i] = ec._EventRequirements_skills(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "training":
			out.Values[i] = ec._EventRequirements_training(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interests":
			out.Values[i] = ec._EventRequirements_interests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventUpdateImplementors = []string{"EventUpdate"}

func (ec *executionContext) _EventUpdate(ctx context.Context, sel ast.SelectionSet, obj *model.EventUpdate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventUpdateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventUpdate")
		case "id":
			out.Values[i] = ec._EventUpdate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedBy":
			out.Values[i] = ec._EventUpdate_updatedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fieldName":
			out.Values[i] = ec._EventUpdate_fieldName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldValue":
			out.Values[i] = ec._EventUpdate_oldValue(ctx, field, obj)
		case "newValue":
			out.Values[i] = ec._EventUpdate_newValue(ctx, field, obj)
		case "updateType":
			out.Values[i] = ec._EventUpdate_updateType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventUpdate_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthImplementors = []string{"Health"}

func (ec *executionContext) _Health(ctx context.Context, sel ast.SelectionSet, obj *model.Health) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Health")
		case "status":
			out.Values[i] = ec._Health_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "time":
			out.Values[i] = ec._Health_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interestImplementors = []string{"Interest"}

func (ec *executionContext) _Interest(ctx context.Context, sel ast.SelectionSet, obj *model.Interest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Interest")
		case "id":
			out.Values[i] = ec._Interest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Interest_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._Interest_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationImplementors = []string{"Location"}

func (ec *executionContext) _Location(ctx context.Context, sel ast.SelectionSet, obj *model.Location) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Location")
		case "city":
			out.Values[i] = ec._Location_city(ctx, field, obj)
		case "state":
			out.Values[i] = ec._Location_state(ctx, field, obj)
		case "country":
			out.Values[i] = ec._Location_country(ctx, field, obj)
		case "coordinates":
			out.Values[i] = ec._Location_coordinates(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "register":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_register(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "login":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_login(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logout":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "googleAuthURL":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_googleAuthURL(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "googleCallback":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_googleCallback(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateProfile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProfile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadProfilePicture":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadProfilePicture(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateInterests":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateInterests(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addSkill":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addSkill(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeSkill":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeSkill(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatePrivacySettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePrivacySettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateNotificationPreferences":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNotificationPreferences(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changePassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_changePassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deactivateAccount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deactivateAccount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exportUserData":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exportUserData(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "publishEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_publishEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addEventImage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addEventImage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEventImage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEventImage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEventImage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEventImage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createEventAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEventAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEventAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEventAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEventAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEventAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerForEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerForEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkRegister":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkRegister(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelRegistration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelRegistration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveRegistration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveRegistration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkInVolunteer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_checkInVolunteer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "markAttendance":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_markAttendance(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "promoteFromWaitlist":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_promoteFromWaitlist(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "transferRegistration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_transferRegistration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRegistration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRegistration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationPreferencesImplementors = []string{"NotificationPreferences"}

func (ec *executionContext) _NotificationPreferences(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationPreferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationPreferencesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationPreferences")
		case "emailNotifications":
			out.Values[i] = ec._NotificationPreferences_emailNotifications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pushNotifications":
			out.Values[i] = ec._NotificationPreferences_pushNotifications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "smsNotifications":
			out.Values[i] = ec._NotificationPreferences_smsNotifications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventReminders":
			out.Values[i] = ec._NotificationPreferences_eventReminders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newOpportunities":
			out.Values[i] = ec._NotificationPreferences_newOpportunities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newsletterSubscription":
			out.Values[i] = ec._NotificationPreferences_newsletterSubscription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var privacySettingsImplementors = []string{"PrivacySettings"}

func (ec *executionContext) _PrivacySettings(ctx context.Context, sel ast.SelectionSet, obj *model.PrivacySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, privacySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrivacySettings")
		case "profileVisibility":
			out.Values[i] = ec._PrivacySettings_profileVisibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "showEmail":
			out.Values[i] = ec._PrivacySettings_showEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "showLocation":
			out.Values[i] = ec._PrivacySettings_showLocation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowMessaging":
			out.Values[i] = ec._PrivacySettings_allowMessaging(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publicProfileImplementors = []string{"PublicProfile"}

func (ec *executionContext) _PublicProfile(ctx context.Context, sel ast.SelectionSet, obj *model.PublicProfile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publicProfileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicProfile")
		case "id":
			out.Values[i] = ec._PublicProfile_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._PublicProfile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bio":
			out.Values[i] = ec._PublicProfile_bio(ctx, field, obj)
		case "location":
			out.Values[i] = ec._PublicProfile_location(ctx, field, obj)
		case "profilePicture":
			out.Values[i] = ec._PublicProfile_profilePicture(ctx, field, obj)
		case "interests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PublicProfile_interests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skills":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PublicProfile_skills(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "volunteerStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PublicProfile_volunteerStats(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "health":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_health(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "interests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interests(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userActivity":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userActivity(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "event":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_event(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "eventBySlug":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_eventBySlug(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nearbyEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nearbyEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "eventUpdates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_eventUpdates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myRegistrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myRegistrations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "registration":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_registration(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "eventRegistrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_eventRegistrations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "waitlistEntries":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_waitlistEntries(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "registrationConflicts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_registrationConflicts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "attendanceRecords":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attendanceRecords(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "registrationStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_registrationStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recurrenceRuleImplementors = []string{"RecurrenceRule"}

func (ec *executionContext) _RecurrenceRule(ctx context.Context, sel ast.SelectionSet, obj *model.RecurrenceRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recurrenceRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecurrenceRule")
		case "frequency":
			out.Values[i] = ec._RecurrenceRule_frequency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interval":
			out.Values[i] = ec._RecurrenceRule_interval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "daysOfWeek":
			out.Values[i] = ec._RecurrenceRule_daysOfWeek(ctx, field, obj)
		case "dayOfMonth":
			out.Values[i] = ec._RecurrenceRule_dayOfMonth(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._RecurrenceRule_endDate(ctx, field, obj)
		case "occurrenceCount":
			out.Values[i] = ec._RecurrenceRule_occurrenceCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var registrationImplementors = []string{"Registration"}

func (ec *executionContext) _Registration(ctx context.Context, sel ast.SelectionSet, obj *model.Registration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Registration")
		case "id":
			out.Values[i] = ec._Registration_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Registration_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "event":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Registration_event(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Registration_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "personalMessage":
			out.Values[i] = ec._Registration_personalMessage(ctx, field, obj)
		case "skills":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Registration_skills(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "interests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Registration_interests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "appliedAt":
			out.Values[i] = ec._Registration_appliedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "confirmedAt":
			out.Values[i] = ec._Registration_confirmedAt(ctx, field, obj)
		case "cancelledAt":
			out.Values[i] = ec._Registration_cancelledAt(ctx, field, obj)
		case "checkedInAt":
			out.Values[i] = ec._Registration_checkedInAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._Registration_completedAt(ctx, field, obj)
		case "waitlistPosition":
			out.Values[i] = ec._Registration_waitlistPosition(ctx, field, obj)
		case "approvalNotes":
			out.Values[i] = ec._Registration_approvalNotes(ctx, field, obj)
		case "cancellationReason":
			out.Values[i] = ec._Registration_cancellationReason(ctx, field, obj)
		case "attendanceStatus":
			out.Values[i] = ec._Registration_attendanceStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canCancel":
			out.Values[i] = ec._Registration_canCancel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canCheckIn":
			out.Values[i] = ec._Registration_canCheckIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Registration_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Registration_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var registrationConflictImplementors = []string{"RegistrationConflict"}

func (ec *executionContext) _RegistrationConflict(ctx context.Context, sel ast.SelectionSet, obj *model.RegistrationConflict) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationConflictImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegistrationConflict")
		case "conflictingEvent":
			out.Values[i] = ec._RegistrationConflict_conflictingEvent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflictType":
			out.Values[i] = ec._RegistrationConflict_conflictType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._RegistrationConflict_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestions":
			out.Values[i] = ec._RegistrationConflict_suggestions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var registrationSettingsImplementors = []string{"RegistrationSettings"}

func (ec *executionContext) _RegistrationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.RegistrationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegistrationSettings")
		case "opensAt":
			out.Values[i] = ec._RegistrationSettings_opensAt(ctx, field, obj)
		case "closesAt":
			out.Values[i] = ec._RegistrationSettings_closesAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiresApproval":
			out.Values[i] = ec._RegistrationSettings_requiresApproval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowWaitlist":
			out.Values[i] = ec._RegistrationSettings_allowWaitlist(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmationRequired":
			out.Values[i] = ec._RegistrationSettings_confirmationRequired(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancellationDeadline":
			out.Values[i] = ec._RegistrationSettings_cancellationDeadline(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var registrationStatsImplementors = []string{"RegistrationStats"}

func (ec *executionContext) _RegistrationStats(ctx context.Context, sel ast.SelectionSet, obj *model.RegistrationStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegistrationStats")
		case "totalRegistrations":
			out.Values[i] = ec._RegistrationStats_totalRegistrations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmedRegistrations":
			out.Values[i] = ec._RegistrationStats_confirmedRegistrations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "waitlistCount":
			out.Values[i] = ec._RegistrationStats_waitlistCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attendanceRate":
			out.Values[i] = ec._RegistrationStats_attendanceRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "noShowRate":
			out.Values[i] = ec._RegistrationStats_noShowRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancellationRate":
			out.Values[i] = ec._RegistrationStats_cancellationRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var skillImplementors = []string{"Skill"}

func (ec *executionContext) _Skill(ctx context.Context, sel ast.SelectionSet, obj *model.Skill) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, skillImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Skill")
		case "id":
			out.Values[i] = ec._Skill_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Skill_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proficiency":
			out.Values[i] = ec._Skill_proficiency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "verified":
			out.Values[i] = ec._Skill_verified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var skillRequirementImplementors = []string{"SkillRequirement"}

func (ec *executionContext) _SkillRequirement(ctx context.Context, sel ast.SelectionSet, obj *model.SkillRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, skillRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SkillRequirement")
		case "id":
			out.Values[i] = ec._SkillRequirement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "skill":
			out.Values[i] = ec._SkillRequirement_skill(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proficiency":
			out.Values[i] = ec._SkillRequirement_proficiency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "required":
			out.Values[i] = ec._SkillRequirement_required(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var trainingRequirementImplementors = []string{"TrainingRequirement"}

func (ec *executionContext) _TrainingRequirement(ctx context.Context, sel ast.SelectionSet, obj *model.TrainingRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, trainingRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TrainingRequirement")
		case "id":
			out.Values[i] = ec._TrainingRequirement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._TrainingRequirement_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._TrainingRequirement_description(ctx, field, obj)
		case "required":
			out.Values[i] = ec._TrainingRequirement_required(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "providedByOrganizer":
			out.Values[i] = ec._TrainingRequirement_providedByOrganizer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "emailVerified":
			out.Values[i] = ec._User_emailVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "googleId":
			out.Values[i] = ec._User_googleId(ctx, field, obj)
		case "lastLogin":
			out.Values[i] = ec._User_lastLogin(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bio":
			out.Values[i] = ec._User_bio(ctx, field, obj)
		case "location":
			out.Values[i] = ec._User_location(ctx, field, obj)
		case "profilePicture":
			out.Values[i] = ec._User_profilePicture(ctx, field, obj)
		case "interests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_interests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skills":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_skills(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isVerified":
			out.Values[i] = ec._User_isVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "joinedAt":
			out.Values[i] = ec._User_joinedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastActiveAt":
			out.Values[i] = ec._User_lastActiveAt(ctx, field, obj)
		case "publicProfile":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_publicProfile(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSkillImplementors = []string{"UserSkill"}

func (ec *executionContext) _UserSkill(ctx context.Context, sel ast.SelectionSet, obj *model.UserSkill) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSkillImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSkill")
		case "id":
			out.Values[i] = ec._UserSkill_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._UserSkill_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proficiency":
			out.Values[i] = ec._UserSkill_proficiency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var volunteerStatsImplementors = []string{"VolunteerStats"}

func (ec *executionContext) _VolunteerStats(ctx context.Context, sel ast.SelectionSet, obj *model.VolunteerStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, volunteerStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VolunteerStats")
		case "hours":
			out.Values[i] = ec._VolunteerStats_hours(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventsParticipated":
			out.Values[i] = ec._VolunteerStats_eventsParticipated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waitlistEntryImplementors = []string{"WaitlistEntry"}

func (ec *executionContext) _WaitlistEntry(ctx context.Context, sel ast.SelectionSet, obj *model.WaitlistEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waitlistEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaitlistEntry")
		case "id":
			out.Values[i] = ec._WaitlistEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registration":
			out.Values[i] = ec._WaitlistEntry_registration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._WaitlistEntry_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "estimatedPromotionTime":
			out.Values[i] = ec._WaitlistEntry_estimatedPromotionTime(ctx, field, obj)
		case "promotionOfferedAt":
			out.Values[i] = ec._WaitlistEntry_promotionOfferedAt(ctx, field, obj)
		case "promotionExpiresAt":
			out.Values[i] = ec._WaitlistEntry_promotionExpiresAt(ctx, field, obj)
		case "autoPromote":
			out.Values[i] = ec._WaitlistEntry_autoPromote(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActivityLog2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐActivityLogᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ActivityLog) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNActivityLog2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐActivityLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNActivityLog2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐActivityLog(ctx context.Context, sel ast.SelectionSet, v *model.ActivityLog) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ActivityLog(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApprovalDecisionInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐApprovalDecisionInput(ctx context.Context, v any) (model.ApprovalDecisionInput, error) {
	res, err := ec.unmarshalInputApprovalDecisionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAttendanceInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceInput(ctx context.Context, v any) (model.AttendanceInput, error) {
	res, err := ec.unmarshalInputAttendanceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAttendanceRecord2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecord(ctx context.Context, sel ast.SelectionSet, v model.AttendanceRecord) graphql.Marshaler {
	return ec._AttendanceRecord(ctx, sel, &v)
}

func (ec *executionContext) marshalNAttendanceRecord2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecordᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.AttendanceRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttendanceRecord2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAttendanceRecord2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceRecord(ctx context.Context, sel ast.SelectionSet, v *model.AttendanceRecord) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AttendanceRecord(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAttendanceStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatus(ctx context.Context, v any) (model.AttendanceStatus, error) {
	var res model.AttendanceStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAttendanceStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatus(ctx context.Context, sel ast.SelectionSet, v model.AttendanceStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAuthPayload2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAuthPayload(ctx context.Context, sel ast.SelectionSet, v model.AuthPayload) graphql.Marshaler {
	return ec._AuthPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuthPayload2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAuthPayload(ctx context.Context, sel ast.SelectionSet, v *model.AuthPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBulkRegistrationInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐBulkRegistrationInput(ctx context.Context, v any) (model.BulkRegistrationInput, error) {
	res, err := ec.unmarshalInputBulkRegistrationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNConflictSeverity2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐConflictSeverity(ctx context.Context, v any) (model.ConflictSeverity, error) {
	var res model.ConflictSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConflictSeverity2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐConflictSeverity(ctx context.Context, sel ast.SelectionSet, v model.ConflictSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNConflictType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐConflictType(ctx context.Context, v any) (model.ConflictType, error) {
	var res model.ConflictType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConflictType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐConflictType(ctx context.Context, sel ast.SelectionSet, v model.ConflictType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCoordinatesInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinatesInput(ctx context.Context, v any) (model.CoordinatesInput, error) {
	res, err := ec.unmarshalInputCoordinatesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEventInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCreateEventInput(ctx context.Context, v any) (model.CreateEventInput, error) {
	res, err := ec.unmarshalInputCreateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDayOfWeek2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeek(ctx context.Context, v any) (model.DayOfWeek, error) {
	var res model.DayOfWeek
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDayOfWeek2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeek(ctx context.Context, sel ast.SelectionSet, v model.DayOfWeek) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEvent2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx context.Context, sel ast.SelectionSet, v model.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx context.Context, sel ast.SelectionSet, v *model.Event) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) marshalNEventAnnouncement2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncement(ctx context.Context, sel ast.SelectionSet, v model.EventAnnouncement) graphql.Marshaler {
	return ec._EventAnnouncement(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventAnnouncement2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncementᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.EventAnnouncement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventAnnouncement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEventAnnouncement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventAnnouncement(ctx context.Context, sel ast.SelectionSet, v *model.EventAnnouncement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventAnnouncement(ctx, sel, v)
}

func (ec *executionContext) marshalNEventCapacity2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCapacity(ctx context.Context, sel ast.SelectionSet, v *model.EventCapacity) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventCapacity(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventCapacityInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCapacityInput(ctx context.Context, v any) (*model.EventCapacityInput, error) {
	res, err := ec.unmarshalInputEventCapacityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx context.Context, v any) (model.EventCategory, error) {
	var res model.EventCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx context.Context, sel ast.SelectionSet, v model.EventCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEventConnection2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventConnection(ctx context.Context, sel ast.SelectionSet, v model.EventConnection) graphql.Marshaler {
	return ec._EventConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventConnection2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventConnection(ctx context.Context, sel ast.SelectionSet, v *model.EventConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNEventEdge2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.EventEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventEdge2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEventEdge2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventEdge(ctx context.Context, sel ast.SelectionSet, v *model.EventEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNEventImage2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImage(ctx context.Context, sel ast.SelectionSet, v model.EventImage) graphql.Marshaler {
	return ec._EventImage(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventImage2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.EventImage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventImage2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEventImage2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventImage(ctx context.Context, sel ast.SelectionSet, v *model.EventImage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventImage(ctx, sel, v)
}

func (ec *executionContext) marshalNEventLocation2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventLocation(ctx context.Context, sel ast.SelectionSet, v *model.EventLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventLocationInput(ctx context.Context, v any) (*model.EventLocationInput, error) {
	res, err := ec.unmarshalInputEventLocationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventRequirements2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventRequirements(ctx context.Context, sel ast.SelectionSet, v *model.EventRequirements) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventRequirements(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventSortField2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSortField(ctx context.Context, v any) (model.EventSortField, error) {
	var res model.EventSortField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSortField2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSortField(ctx context.Context, sel ast.SelectionSet, v model.EventSortField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatus(ctx context.Context, v any) (model.EventStatus, error) {
	var res model.EventStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatus(ctx context.Context, sel ast.SelectionSet, v model.EventStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEventUpdate2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventUpdateᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.EventUpdate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventUpdate2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventUpdate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEventUpdate2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventUpdate(ctx context.Context, sel ast.SelectionSet, v *model.EventUpdate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventUpdate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNHealth2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐHealth(ctx context.Context, sel ast.SelectionSet, v model.Health) graphql.Marshaler {
	return ec._Health(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealth2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐHealth(ctx context.Context, sel ast.SelectionSet, v *model.Health) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Health(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNInterest2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Interest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterest2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterest2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterest(ctx context.Context, sel ast.SelectionSet, v *model.Interest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Interest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInterestCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestCategory(ctx context.Context, v any) (model.InterestCategory, error) {
	var res model.InterestCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInterestCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestCategory(ctx context.Context, sel ast.SelectionSet, v model.InterestCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInterestInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐInterestInput(ctx context.Context, v any) (model.InterestInput, error) {
	res, err := ec.unmarshalInputInterestInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLoginInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLoginInput(ctx context.Context, v any) (model.LoginInput, error) {
	res, err := ec.unmarshalInputLoginInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNotificationPreferencesInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐNotificationPreferencesInput(ctx context.Context, v any) (model.NotificationPreferencesInput, error) {
	res, err := ec.unmarshalInputNotificationPreferencesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageInfo2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPrivacySettingsInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPrivacySettingsInput(ctx context.Context, v any) (model.PrivacySettingsInput, error) {
	res, err := ec.unmarshalInputPrivacySettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProfileVisibility2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐProfileVisibility(ctx context.Context, v any) (model.ProfileVisibility, error) {
	var res model.ProfileVisibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProfileVisibility2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐProfileVisibility(ctx context.Context, sel ast.SelectionSet, v model.ProfileVisibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPublicProfile2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfile(ctx context.Context, sel ast.SelectionSet, v model.PublicProfile) graphql.Marshaler {
	return ec._PublicProfile(ctx, sel, &v)
}

func (ec *executionContext) marshalNPublicProfile2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfileᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PublicProfile) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublicProfile2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPublicProfile2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfile(ctx context.Context, sel ast.SelectionSet, v *model.PublicProfile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PublicProfile(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRecurrenceFrequency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceFrequency(ctx context.Context, v any) (model.RecurrenceFrequency, error) {
	var res model.RecurrenceFrequency
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRecurrenceFrequency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceFrequency(ctx context.Context, sel ast.SelectionSet, v model.RecurrenceFrequency) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRefreshTokenInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRefreshTokenInput(ctx context.Context, v any) (model.RefreshTokenInput, error) {
	res, err := ec.unmarshalInputRefreshTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRegisterForEventInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegisterForEventInput(ctx context.Context, v any) (model.RegisterForEventInput, error) {
	res, err := ec.unmarshalInputRegisterForEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRegisterInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegisterInput(ctx context.Context, v any) (model.RegisterInput, error) {
	res, err := ec.unmarshalInputRegisterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRegistration2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx context.Context, sel ast.SelectionSet, v model.Registration) graphql.Marshaler {
	return ec._Registration(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegistration2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Registration) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx context.Context, sel ast.SelectionSet, v *model.Registration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Registration(ctx, sel, v)
}

func (ec *executionContext) marshalNRegistrationConflict2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationConflictᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.RegistrationConflict) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRegistrationConflict2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRegistrationConflict2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationConflict(ctx context.Context, sel ast.SelectionSet, v *model.RegistrationConflict) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegistrationConflict(ctx, sel, v)
}

func (ec *executionContext) marshalNRegistrationSettings2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationSettings(ctx context.Context, sel ast.SelectionSet, v *model.RegistrationSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegistrationSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRegistrationSettingsInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationSettingsInput(ctx context.Context, v any) (*model.RegistrationSettingsInput, error) {
	res, err := ec.unmarshalInputRegistrationSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRegistrationStats2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStats(ctx context.Context, sel ast.SelectionSet, v model.RegistrationStats) graphql.Marshaler {
	return ec._RegistrationStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegistrationStats2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStats(ctx context.Context, sel ast.SelectionSet, v *model.RegistrationStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegistrationStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRegistrationStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatus(ctx context.Context, v any) (model.RegistrationStatus, error) {
	var res model.RegistrationStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRegistrationStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatus(ctx context.Context, sel ast.SelectionSet, v model.RegistrationStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSkill2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Skill) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSkill2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSkill2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkill(ctx context.Context, sel ast.SelectionSet, v *model.Skill) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Skill(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSkillInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillInput(ctx context.Context, v any) (model.SkillInput, error) {
	res, err := ec.unmarshalInputSkillInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx context.Context, v any) (model.SkillProficiency, error) {
	var res model.SkillProficiency
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSkillProficiency2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillProficiency(ctx context.Context, sel ast.SelectionSet, v model.SkillProficiency) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSkillRequirement2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirementᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.SkillRequirement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSkillRequirement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSkillRequirement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirement(ctx context.Context, sel ast.SelectionSet, v *model.SkillRequirement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SkillRequirement(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSkillRequirementInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirementInput(ctx context.Context, v any) (*model.SkillRequirementInput, error) {
	res, err := ec.unmarshalInputSkillRequirementInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSortDirection2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSortDirection(ctx context.Context, v any) (model.SortDirection, error) {
	var res model.SortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortDirection2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSortDirection(ctx context.Context, sel ast.SelectionSet, v model.SortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := ec.unmarshalInputTime(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return ec._Time(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTimeCommitmentType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentType(ctx context.Context, v any) (model.TimeCommitmentType, error) {
	var res model.TimeCommitmentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimeCommitmentType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentType(ctx context.Context, sel ast.SelectionSet, v model.TimeCommitmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTrainingRequirement2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirementᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TrainingRequirement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrainingRequirement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTrainingRequirement2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirement(ctx context.Context, sel ast.SelectionSet, v *model.TrainingRequirement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TrainingRequirement(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTrainingRequirementInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirementInput(ctx context.Context, v any) (*model.TrainingRequirementInput, error) {
	res, err := ec.unmarshalInputTrainingRequirementInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEventInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateEventInput(ctx context.Context, v any) (model.UpdateEventInput, error) {
	res, err := ec.unmarshalInputUpdateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProfileInput2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateProfileInput(ctx context.Context, v any) (model.UpdateProfileInput, error) {
	res, err := ec.unmarshalInputUpdateProfileInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateType(ctx context.Context, v any) (model.UpdateType, error) {
	var res model.UpdateType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUpdateType(ctx context.Context, sel ast.SelectionSet, v model.UpdateType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v any) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserSearchFilter2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUserSearchFilter(ctx context.Context, v any) (model.UserSearchFilter, error) {
	res, err := ec.unmarshalInputUserSearchFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserSkill2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUserSkillᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.UserSkill) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSkill2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUserSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserSkill2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUserSkill(ctx context.Context, sel ast.SelectionSet, v *model.UserSkill) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSkill(ctx, sel, v)
}

func (ec *executionContext) marshalNVolunteerStats2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐVolunteerStats(ctx context.Context, sel ast.SelectionSet, v model.VolunteerStats) graphql.Marshaler {
	return ec._VolunteerStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNVolunteerStats2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐVolunteerStats(ctx context.Context, sel ast.SelectionSet, v *model.VolunteerStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VolunteerStats(ctx, sel, v)
}

func (ec *executionContext) marshalNWaitlistEntry2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐWaitlistEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.WaitlistEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaitlistEntry2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐWaitlistEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWaitlistEntry2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐWaitlistEntry(ctx context.Context, sel ast.SelectionSet, v *model.WaitlistEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaitlistEntry(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAttendanceStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatusᚄ(ctx context.Context, v any) ([]model.AttendanceStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.AttendanceStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAttendanceStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAttendanceStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatusᚄ(ctx context.Context, sel ast.SelectionSet, v []model.AttendanceStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttendanceStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAttendanceStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAvailabilityStatus2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAvailabilityStatus(ctx context.Context, v any) (*model.AvailabilityStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.AvailabilityStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAvailabilityStatus2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐAvailabilityStatus(ctx context.Context, sel ast.SelectionSet, v *model.AvailabilityStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCoordinates2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinates(ctx context.Context, sel ast.SelectionSet, v *model.Coordinates) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Coordinates(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoordinatesInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐCoordinatesInput(ctx context.Context, v any) (*model.CoordinatesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoordinatesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODateRangeInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDateRangeInput(ctx context.Context, v any) (*model.DateRangeInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDateRangeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODateTime2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalODayOfWeek2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeekᚄ(ctx context.Context, v any) ([]model.DayOfWeek, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.DayOfWeek, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDayOfWeek2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeek(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODayOfWeek2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeekᚄ(ctx context.Context, sel ast.SelectionSet, v []model.DayOfWeek) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDayOfWeek2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐDayOfWeek(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEmergencyContactInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEmergencyContactInput(ctx context.Context, v any) (*model.EmergencyContactInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEmergencyContactInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEvent2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEvent(ctx context.Context, sel ast.SelectionSet, v *model.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventCategory2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategoryᚄ(ctx context.Context, v any) ([]model.EventCategory, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.EventCategory, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEventCategory2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []model.EventCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventCategory2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEventCategory2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx context.Context, v any) (*model.EventCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventCategory2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventCategory(ctx context.Context, sel ast.SelectionSet, v *model.EventCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventLocationInput(ctx context.Context, v any) (*model.EventLocationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventLocationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventRequirementsInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventRequirementsInput(ctx context.Context, v any) (*model.EventRequirementsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventRequirementsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventSearchFilter2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSearchFilter(ctx context.Context, v any) (*model.EventSearchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventSearchFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventSortInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventSortInput(ctx context.Context, v any) (*model.EventSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventSortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatusᚄ(ctx context.Context, v any) ([]model.EventStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.EventStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEventStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatusᚄ(ctx context.Context, sel ast.SelectionSet, v []model.EventStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐEventStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOExperienceLevel2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐExperienceLevel(ctx context.Context, v any) (*model.ExperienceLevel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ExperienceLevel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOExperienceLevel2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐExperienceLevel(ctx context.Context, sel ast.SelectionSet, v *model.ExperienceLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLocation2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLocationInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocationInput(ctx context.Context, v any) (*model.LocationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLocationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLocationSearchInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐLocationSearchInput(ctx context.Context, v any) (*model.LocationSearchInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLocationSearchInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProfileVisibility2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐProfileVisibility(ctx context.Context, v any) (*model.ProfileVisibility, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProfileVisibility)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProfileVisibility2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐProfileVisibility(ctx context.Context, sel ast.SelectionSet, v *model.ProfileVisibility) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOPublicProfile2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐPublicProfile(ctx context.Context, sel ast.SelectionSet, v *model.PublicProfile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PublicProfile(ctx, sel, v)
}

func (ec *executionContext) marshalORecurrenceRule2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceRule(ctx context.Context, sel ast.SelectionSet, v *model.RecurrenceRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RecurrenceRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalORecurrenceRuleInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRecurrenceRuleInput(ctx context.Context, v any) (*model.RecurrenceRuleInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRecurrenceRuleInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORegistration2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistration(ctx context.Context, sel ast.SelectionSet, v *model.Registration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Registration(ctx, sel, v)
}

func (ec *executionContext) unmarshalORegistrationFilterInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationFilterInput(ctx context.Context, v any) (*model.RegistrationFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRegistrationFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORegistrationStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatusᚄ(ctx context.Context, v any) ([]model.RegistrationStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.RegistrationStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRegistrationStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORegistrationStatus2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatusᚄ(ctx context.Context, sel ast.SelectionSet, v []model.RegistrationStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRegistrationStatus2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐRegistrationStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSkillRequirementInput2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirementInputᚄ(ctx context.Context, v any) ([]*model.SkillRequirementInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.SkillRequirementInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSkillRequirementInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐSkillRequirementInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTime(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Time(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTimeCommitmentType2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentTypeᚄ(ctx context.Context, v any) ([]model.TimeCommitmentType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.TimeCommitmentType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTimeCommitmentType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTimeCommitmentType2ᚕgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []model.TimeCommitmentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTimeCommitmentType2githubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTimeCommitmentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTrainingRequirementInput2ᚕᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirementInputᚄ(ctx context.Context, v any) ([]*model.TrainingRequirementInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.TrainingRequirementInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTrainingRequirementInput2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐTrainingRequirementInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋvolunteersyncᚋbackendᚋinternalᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
